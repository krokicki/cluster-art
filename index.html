<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Resource Visualization</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #tooltip {
            position: fixed;
            left: 20px;
            padding: 16px 20px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            line-height: 1.8;
            color: #00ff00;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            white-space: nowrap;
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip.bottom {
            bottom: 20px;
        }

        #tooltip.top {
            top: 20px;
        }

        #tooltip .label {
            color: #ffff00;
            text-shadow: 0 0 5px rgba(255, 255, 0, 0.7);
        }

        #tooltip .value {
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.7);
        }

        #tooltip .idle {
            color: #ff00ff;
            text-shadow: 0 0 5px rgba(255, 0, 255, 0.7);
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 400px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            line-height: 2;
            color: #00ff00;
            z-index: 999;
        }

        #legend-title {
            color: #ffff00;
            text-align: center;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        #legend-title:hover {
            background: #00ff00;
            color: #1a1a2e;
        }

        #legend-title::after {
            content: ' [L]';
            color: #00ff00;
            font-size: 8px;
        }

        #legend-title:hover::after {
            color: #1a1a2e;
        }

        #legend-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        #legend.expanded #legend-content {
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        #legend-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 16px;
            border-top: 2px solid #00ff00;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 2px solid #00ff00;
            flex-shrink: 0;
        }

        .legend-user {
            color: #00ffff;
            word-break: break-all;
        }

        .legend-count {
            color: #ff00ff;
            margin-left: auto;
            flex-shrink: 0;
        }

        #legend-content::-webkit-scrollbar {
            width: 8px;
        }

        #legend-content::-webkit-scrollbar-track {
            background: #0f0f1e;
        }

        #legend-content::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        #mode-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 16px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            color: #00ff00;
            z-index: 1000;
            white-space: nowrap;
        }

        #mode-indicator .mode-number {
            color: #ffff00;
        }

        /* Modal dialog */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #modal-overlay.visible {
            display: flex;
        }

        #modal {
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 12px 12px 0px rgba(0, 0, 0, 0.9);
            padding: 24px;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Press Start 2P', monospace;
            color: #00ff00;
        }

        #modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #00ff00;
        }

        #modal-title {
            font-size: 12px;
            color: #ffff00;
        }

        #modal-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 40px;
        }

        @media (max-width: 768px) {
            #modal {
                max-width: 90vw;
                width: 90vw;
            }

            #modal-content {
                grid-template-columns: 1fr;
            }
        }


        .modal-section {
            margin-bottom: 20px;
        }

        .modal-section-title {
            color: #00ffff;
            font-size: 10px;
            margin-bottom: 10px;
        }

        .modal-info-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 8px;
            line-height: 1.6;
        }

        .modal-label {
            color: #ffff00;
            min-width: 100px;
        }

        .modal-value {
            color: #00ff00;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border: 2px solid;
            font-size: 8px;
        }

        .status-badge.in-use {
            border-color: #44ff44;
            color: #44ff44;
        }

        .status-badge.idle {
            border-color: #ff00ff;
            color: #ff00ff;
        }

        .bar-graph {
            margin-top: 8px;
        }

        .bar-graph-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 8px;
        }

        .bar-graph-label {
            color: #ffff00;
            min-width: 60px;
        }

        .bar-graph-container {
            flex: 1;
            height: 16px;
            background: #0a0a1a;
            border: 2px solid #00ff00;
            position: relative;
        }

        .bar-graph-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #44ff44);
            transition: width 0.3s ease;
        }

        .bar-graph-value {
            color: #00ffff;
            min-width: 60px;
            text-align: right;
        }

        .type-icon {
            font-size: 24px;
            line-height: 1;
        }

        #modal::-webkit-scrollbar {
            width: 8px;
        }

        #modal::-webkit-scrollbar-track {
            background: #0f0f1e;
        }

        #modal::-webkit-scrollbar-thumb {
            background: #00ff00;
        }
    </style>
</head>
<body>
    <canvas id="grid"></canvas>
    <div id="tooltip" class="bottom"></div>
    <div id="mode-indicator"><span class="mode-number">1</span> USER</div>
    <div id="legend">
        <div id="legend-title">LEGEND</div>
        <div id="legend-content">
            <div id="legend-items"></div>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="modal">
            <div id="modal-header">
                <div id="modal-title">RESOURCE DETAILS</div>
            </div>
            <div id="modal-content"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');

        // Configuration
        const PIXEL_SIZE = 8; // Size of each square pixel

        let gridWidth, gridHeight;
        let resources = [];
        let userColorMap = new Map();

        // Color mode management
        const MODE_DESCRIPTIONS = [
            'USER',
            'HOSTNAME',
            'ROW',
            'CPU/GPU',
            'GPU TYPE',
            'UTILIZATION',
            'SLOT STATUS',
            'HOST STATUS',
            'MEMORY'
        ];

        let currentColorMode = 1;
        let colorStrategies = [];

        // Resource model
        class Resource {
            constructor(hostname, type, index, user, hostData) {
                this.hostname = hostname;
                this.type = type; // 'cpu' or 'gpu'
                this.index = index; // Index within the host
                this.user = user || null; // Username or null if idle
                this.x = 0; // Grid position
                this.y = 0;

                // Additional metadata from host
                this.gpuType = hostData?.gpu_type || null;
                this.utilization = hostData?.utilization || 0;
                this.status = hostData?.status || 'unknown';
                this.load = hostData?.load || {};
            }

            get isIdle() {
                return !this.user || this.user === '';
            }

            get row() {
                // Extract row prefix (e.g., "h04" from "h04u08")
                const match = this.hostname.match(/^([a-z]+\d+)/);
                return match ? match[1] : this.hostname;
            }
        }

        // Layout strategy interface
        class LayoutStrategy {
            layout(resources, gridWidth, gridHeight) {
                throw new Error('layout() must be implemented');
            }
        }

        // Hostname-based hierarchical layout
        class HostnameHierarchyLayout extends LayoutStrategy {
            layout(resources, gridWidth, gridHeight) {
                // Group resources by hostname
                const hostGroups = new Map();
                resources.forEach(resource => {
                    if (!hostGroups.has(resource.hostname)) {
                        hostGroups.set(resource.hostname, []);
                    }
                    hostGroups.get(resource.hostname).push(resource);
                });

                // Sort hostnames alphabetically for spatial proximity
                const sortedHostnames = Array.from(hostGroups.keys()).sort();

                // Calculate positions
                let x = 0, y = 0;
                const maxWidth = gridWidth;

                sortedHostnames.forEach(hostname => {
                    const hostResources = hostGroups.get(hostname);

                    // Place all resources from this host together
                    hostResources.forEach((resource, idx) => {
                        resource.x = x;
                        resource.y = y;

                        x++;
                        if (x >= maxWidth) {
                            x = 0;
                            y++;
                        }
                    });

                    // Add small gap between hosts (optional)
                    // x++;
                    // if (x >= maxWidth) {
                    //     x = 0;
                    //     y++;
                    // }
                });
            }
        }

        // User-based layout (for future use)
        class UserGroupLayout extends LayoutStrategy {
            layout(resources, gridWidth, gridHeight) {
                // Group resources by user
                const userGroups = new Map();
                resources.forEach(resource => {
                    const user = resource.user || 'idle';
                    if (!userGroups.has(user)) {
                        userGroups.set(user, []);
                    }
                    userGroups.get(user).push(resource);
                });

                // Sort users alphabetically
                const sortedUsers = Array.from(userGroups.keys()).sort();

                // Calculate positions
                let x = 0, y = 0;
                const maxWidth = gridWidth;

                sortedUsers.forEach(user => {
                    const userResources = userGroups.get(user);

                    userResources.forEach(resource => {
                        resource.x = x;
                        resource.y = y;

                        x++;
                        if (x >= maxWidth) {
                            x = 0;
                            y++;
                        }
                    });
                });
            }
        }

        // Color strategy interface
        class ColorStrategy {
            constructor() {
                this.colorMap = new Map();
            }

            getColor(resource) {
                throw new Error('getColor() must be implemented');
            }

            getLegendItems(resources) {
                throw new Error('getLegendItems() must be implemented');
            }

            initialize(resources) {
                // Override if needed to pre-compute colors
            }
        }

        // Mode 1: By User
        class UserColorStrategy extends ColorStrategy {
            initialize(resources) {
                const users = resources.map(r => r.user).filter(u => u && u !== '');
                const uniqueUsers = Array.from(new Set(users));
                const colors = generateDistinctColors(uniqueUsers.length);

                uniqueUsers.forEach((user, i) => {
                    this.colorMap.set(user, colors[i]);
                });
                this.colorMap.set(null, '#2a2a2a');
                this.colorMap.set('', '#2a2a2a');
            }

            getColor(resource) {
                return this.colorMap.get(resource.user) || this.colorMap.get(null);
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    const key = r.user || 'idle';
                    counts.set(key, (counts.get(key) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => {
                        if (a === 'idle') return 1;
                        if (b === 'idle') return -1;
                        return counts.get(b) - counts.get(a);
                    })
                    .map(key => ({
                        label: key === 'idle' ? 'IDLE' : key,
                        color: this.getColor({ user: key === 'idle' ? null : key }),
                        count: counts.get(key)
                    }));
            }
        }

        // Mode 2: By Hostname
        class HostnameColorStrategy extends ColorStrategy {
            initialize(resources) {
                const hostnames = Array.from(new Set(resources.map(r => r.hostname))).sort();
                const colors = generateRandomColors(hostnames.length);
                hostnames.forEach((hostname, i) => {
                    this.colorMap.set(hostname, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.hostname) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.hostname, (counts.get(r.hostname) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort()
                    .map(hostname => ({
                        label: hostname,
                        color: this.colorMap.get(hostname),
                        count: counts.get(hostname)
                    }));
            }
        }

        // Mode 3: By Row
        class RowColorStrategy extends ColorStrategy {
            initialize(resources) {
                const rows = Array.from(new Set(resources.map(r => r.row))).sort();
                const colors = generateRandomColors(rows.length);
                rows.forEach((row, i) => {
                    this.colorMap.set(row, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.row) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.row, (counts.get(r.row) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort()
                    .map(row => ({
                        label: row,
                        color: this.colorMap.get(row),
                        count: counts.get(row)
                    }));
            }
        }

        // Mode 4: By Resource Type (CPU/GPU)
        class TypeColorStrategy extends ColorStrategy {
            constructor() {
                super();
                this.colorMap.set('cpu', '#4488ff'); // Blue
                this.colorMap.set('gpu', '#ff8844'); // Orange
            }

            getColor(resource) {
                return this.colorMap.get(resource.type);
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.type, (counts.get(r.type) || 0) + 1);
                });

                return ['cpu', 'gpu'].map(type => ({
                    label: type.toUpperCase(),
                    color: this.colorMap.get(type),
                    count: counts.get(type) || 0
                }));
            }
        }

        // Mode 5: By GPU Type
        class GpuTypeColorStrategy extends ColorStrategy {
            initialize(resources) {
                const gpuTypes = Array.from(new Set(resources.map(r => r.gpuType).filter(t => t)));
                const colors = generateDistinctColors(gpuTypes.length + 1);

                gpuTypes.forEach((type, i) => {
                    this.colorMap.set(type, colors[i]);
                });
                this.colorMap.set(null, colors[gpuTypes.length]); // CPU color
            }

            getColor(resource) {
                return this.colorMap.get(resource.gpuType) || this.colorMap.get(null);
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    const key = r.gpuType || 'CPU';
                    counts.set(key, (counts.get(key) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => {
                        if (a === 'CPU') return 1;
                        if (b === 'CPU') return -1;
                        return a.localeCompare(b);
                    })
                    .map(key => ({
                        label: key,
                        color: this.getColor({ gpuType: key === 'CPU' ? null : key }),
                        count: counts.get(key)
                    }));
            }
        }

        // Mode 6: By Utilization (Heat Map)
        class UtilizationColorStrategy extends ColorStrategy {
            initialize(resources) {
                const utils = resources.map(r => r.utilization);
                this.min = Math.min(...utils);
                this.max = Math.max(...utils);
            }

            getColor(resource) {
                return getHeatMapColor(resource.utilization, this.min, this.max);
            }

            getLegendItems(resources) {
                const ranges = [
                    { label: '0-20%', min: 0, max: 20 },
                    { label: '21-40%', min: 21, max: 40 },
                    { label: '41-60%', min: 41, max: 60 },
                    { label: '61-80%', min: 61, max: 80 },
                    { label: '81-100%', min: 81, max: 100 }
                ];

                return ranges.map(range => {
                    const count = resources.filter(r =>
                        r.utilization >= range.min && r.utilization <= range.max
                    ).length;
                    return {
                        label: range.label,
                        color: getHeatMapColor((range.min + range.max) / 2, 0, 100),
                        count: count
                    };
                });
            }
        }

        // Mode 7: By Slot Status (Idle vs In-Use)
        class StatusColorStrategy extends ColorStrategy {
            constructor() {
                super();
                this.colorMap.set(true, '#2a2a2a');  // Idle
                this.colorMap.set(false, '#44ff44'); // In-use
            }

            getColor(resource) {
                return this.colorMap.get(resource.isIdle);
            }

            getLegendItems(resources) {
                const idleCount = resources.filter(r => r.isIdle).length;
                const inUseCount = resources.length - idleCount;

                return [
                    { label: 'IN-USE', color: this.colorMap.get(false), count: inUseCount },
                    { label: 'IDLE', color: this.colorMap.get(true), count: idleCount }
                ];
            }
        }

        // Mode 8: By Host Status
        class HostStatusColorStrategy extends ColorStrategy {
            initialize(resources) {
                const statuses = Array.from(new Set(resources.map(r => r.status)));
                const colors = generateDistinctColors(statuses.length);
                statuses.forEach((status, i) => {
                    this.colorMap.set(status, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.status) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.status, (counts.get(r.status) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => counts.get(b) - counts.get(a))
                    .map(status => ({
                        label: status,
                        color: this.colorMap.get(status),
                        count: counts.get(status)
                    }));
            }
        }

        // Mode 9: By Memory Load
        class MemoryLoadColorStrategy extends ColorStrategy {
            initialize(resources) {
                const mems = resources.map(r => r.load?.mem || 0);
                this.min = Math.min(...mems);
                this.max = Math.max(...mems);
            }

            getColor(resource) {
                const mem = resource.load?.mem || 0;
                return getHeatMapColor(mem, this.min, this.max);
            }

            getLegendItems(resources) {
                const mems = resources.map(r => r.load?.mem || 0);
                const min = Math.min(...mems);
                const max = Math.max(...mems);
                const range = max - min;
                const step = range / 5;

                const ranges = [];
                for (let i = 0; i < 5; i++) {
                    const rangeMin = min + (step * i);
                    const rangeMax = min + (step * (i + 1));
                    const count = resources.filter(r => {
                        const mem = r.load?.mem || 0;
                        return mem >= rangeMin && mem < (i === 4 ? rangeMax + 1 : rangeMax);
                    }).length;

                    ranges.push({
                        label: `${Math.round(rangeMin)}-${Math.round(rangeMax)}`,
                        color: getHeatMapColor((rangeMin + rangeMax) / 2, min, max),
                        count: count
                    });
                }

                return ranges;
            }
        }

        // Helper color generation functions
        function generateDistinctColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                const saturation = 70;
                const lightness = 60;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function generateRandomColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = Math.random() * 360;
                const saturation = 60 + Math.random() * 20;
                const lightness = 50 + Math.random() * 20;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function getHeatMapColor(value, min, max) {
            if (max === min) return 'hsl(120, 70%, 50%)'; // All same value, use middle color
            const normalized = Math.max(0, Math.min(1, (value - min) / (max - min)));
            const hue = (1 - normalized) * 240; // 240 = blue (low), 0 = red (high)
            return `hsl(${hue}, 80%, 50%)`;
        }

        // Generate colors for users
        function generateUserColors(users) {
            const colors = new Map();
            const uniqueUsers = Array.from(new Set(users)).filter(u => u && u !== '');

            uniqueUsers.forEach((user, i) => {
                const hue = (i * 360 / uniqueUsers.length) % 360;
                const saturation = 65 + Math.random() * 15;
                const lightness = 55 + Math.random() * 15;
                colors.set(user, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
            });

            // Color for idle resources
            colors.set(null, '#2a2a2a');
            colors.set('', '#2a2a2a');

            return colors;
        }

        // Load cluster data from JSON
        async function loadClusterData() {
            try {
                const response = await fetch('cluster-status.json');
                const data = await response.json();

                // Extract resources from hostDetails
                const allResources = [];
                const allUsers = [];

                data.hostDetails.forEach(host => {
                    // Add CPU resources
                    host.cpuSlots.forEach((user, idx) => {
                        allResources.push(new Resource(host.hostname, 'cpu', idx, user, host));
                        if (user && user !== '') allUsers.push(user);
                    });

                    // Add GPU resources
                    host.gpuSlots.forEach((user, idx) => {
                        allResources.push(new Resource(host.hostname, 'gpu', idx, user, host));
                        if (user && user !== '') allUsers.push(user);
                    });
                });

                resources = allResources;
                userColorMap = generateUserColors(allUsers);

                return true;
            } catch (error) {
                console.error('Failed to load cluster data:', error);
                return false;
            }
        }

        // Apply layout strategy
        function applyLayout(strategy) {
            strategy.layout(resources, gridWidth, gridHeight);
        }

        // Initialize color strategies
        function initializeColorStrategies() {
            colorStrategies = [
                new UserColorStrategy(),
                new HostnameColorStrategy(),
                new RowColorStrategy(),
                new TypeColorStrategy(),
                new GpuTypeColorStrategy(),
                new UtilizationColorStrategy(),
                new StatusColorStrategy(),
                new HostStatusColorStrategy(),
                new MemoryLoadColorStrategy()
            ];

            // Initialize each strategy with the resources
            colorStrategies.forEach(strategy => strategy.initialize(resources));
        }

        // Populate legend
        function populateLegend() {
            const legendItems = document.getElementById('legend-items');
            legendItems.innerHTML = '';

            if (colorStrategies.length === 0) return;

            const colorStrategy = colorStrategies[currentColorMode - 1];
            const items = colorStrategy.getLegendItems(resources);

            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'legend-item';
                div.innerHTML = `
                    <div class="legend-color" style="background-color: ${item.color}"></div>
                    <span class="legend-user">${item.label}</span>
                    <span class="legend-count">${item.count}</span>
                `;
                legendItems.appendChild(div);
            });
        }

        // Draw the grid
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (colorStrategies.length === 0) return;

            const colorStrategy = colorStrategies[currentColorMode - 1];

            resources.forEach(resource => {
                const color = colorStrategy.getColor(resource);
                ctx.fillStyle = color;
                ctx.fillRect(
                    resource.x * PIXEL_SIZE,
                    resource.y * PIXEL_SIZE,
                    PIXEL_SIZE,
                    PIXEL_SIZE
                );

                // Draw white border for hovered pixel
                if (currentResource && resource === currentResource) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        resource.x * PIXEL_SIZE + 0.5,
                        resource.y * PIXEL_SIZE + 0.5,
                        PIXEL_SIZE - 1,
                        PIXEL_SIZE - 1
                    );
                }
            });
        }

        // Initialize visualization
        async function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            gridWidth = Math.floor(canvas.width / PIXEL_SIZE);
            gridHeight = Math.floor(canvas.height / PIXEL_SIZE);

            const loaded = await loadClusterData();

            if (loaded) {
                // Initialize color strategies
                initializeColorStrategies();

                // Apply default layout strategy
                const layoutStrategy = new HostnameHierarchyLayout();
                applyLayout(layoutStrategy);
                draw();
                populateLegend();
            } else {
                // Fallback: show error message
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px monospace';
                ctx.fillText('Failed to load cluster-status.json', 20, 30);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            gridWidth = Math.floor(canvas.width / PIXEL_SIZE);
            gridHeight = Math.floor(canvas.height / PIXEL_SIZE);

            if (resources.length > 0) {
                const layoutStrategy = new HostnameHierarchyLayout();
                applyLayout(layoutStrategy);
                draw();
            }
        });

        // Tooltip handling
        const tooltip = document.getElementById('tooltip');
        let currentResource = null;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate grid position
            const gridX = Math.floor(mouseX / PIXEL_SIZE);
            const gridY = Math.floor(mouseY / PIXEL_SIZE);

            // Find resource at this position
            const resource = resources.find(r => r.x === gridX && r.y === gridY);

            if (resource) {
                currentResource = resource;
                showTooltip(resource, e.clientY);
            } else {
                hideTooltip();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hideTooltip();
        });

        function showTooltip(resource, mouseY) {
            const userText = resource.isIdle
                ? '<span class="idle">IDLE</span>'
                : `<span class="value">${resource.user}</span>`;

            tooltip.innerHTML = `
                <span class="label">HOST:</span> <span class="value">${resource.hostname}</span> |
                <span class="label">TYPE:</span> <span class="value">${resource.type.toUpperCase()}</span> |
                <span class="label">SLOT:</span> <span class="value">#${resource.index}</span> |
                <span class="label">USER:</span> ${userText}
            `;

            // Position tooltip based on mouse Y position
            const bottomThreshold = window.innerHeight - 150;
            if (mouseY > bottomThreshold) {
                tooltip.classList.remove('bottom');
                tooltip.classList.add('top');
            } else {
                tooltip.classList.remove('top');
                tooltip.classList.add('bottom');
            }

            tooltip.classList.add('visible');
            draw(); // Redraw to show hover border
        }

        function hideTooltip() {
            currentResource = null;
            tooltip.classList.remove('visible');
            draw(); // Redraw to remove hover border
        }

        // Mode switching
        const modeIndicator = document.getElementById('mode-indicator');

        function updateModeIndicator() {
            const modeNum = currentColorMode;
            const modeName = MODE_DESCRIPTIONS[currentColorMode - 1];
            modeIndicator.innerHTML = `<span class="mode-number">${modeNum}</span> ${modeName}`;
        }

        function switchColorMode(mode) {
            if (mode >= 1 && mode <= 9 && colorStrategies.length > 0) {
                currentColorMode = mode;
                updateModeIndicator();
                populateLegend();
                draw();
            }
        }

        // Legend toggle
        const legend = document.getElementById('legend');
        const legendTitle = document.getElementById('legend-title');
        let legendExpanded = false;

        function toggleLegend() {
            legendExpanded = !legendExpanded;
            if (legendExpanded) {
                legend.classList.add('expanded');
            } else {
                legend.classList.remove('expanded');
            }
        }

        legendTitle.addEventListener('click', toggleLegend);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // L to toggle legend
            if (e.key === 'l' || e.key === 'L') {
                toggleLegend();
            }

            // Number keys 1-9 to switch color modes
            const key = parseInt(e.key);
            if (key >= 1 && key <= 9) {
                switchColorMode(key);
            }

            // ESC to close modal
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        // Modal handling
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modal = document.getElementById('modal');

        function createBarGraph(label, value, max) {
            const percentage = max > 0 ? Math.min(100, (value / max) * 100) : 0;
            const isOverflow = value > max;
            const displayValue = isOverflow ? `${value.toFixed(1)} (!)` : value.toFixed(1);
            const barColor = isOverflow ? 'background: linear-gradient(90deg, #ff0000, #ff4444);' : 'background: linear-gradient(90deg, #00ff00, #44ff44);';

            return `
                <div class="bar-graph-row">
                    <div class="bar-graph-label">${label}</div>
                    <div class="bar-graph-container">
                        <div class="bar-graph-fill" style="width: ${percentage}%; ${barColor}"></div>
                    </div>
                    <div class="bar-graph-value">${displayValue}</div>
                </div>
            `;
        }

        function showModal(resource) {
            const statusBadge = resource.isIdle
                ? '<span class="status-badge idle">IDLE</span>'
                : '<span class="status-badge in-use">IN-USE</span>';

            // Column 1: Basic info and host status
            let column1 = `
                <div>
                    <div class="modal-section">
                        <div class="modal-section-title">▸ BASIC INFO</div>
                        <div class="modal-info-row">
                            <div class="modal-label">TYPE:</div>
                            <div class="modal-value">${resource.type.toUpperCase()}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">HOSTNAME:</div>
                            <div class="modal-value">${resource.hostname}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">ROW:</div>
                            <div class="modal-value">${resource.row}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">SLOT:</div>
                            <div class="modal-value">#${resource.index}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">STATUS:</div>
                            <div class="modal-value">${statusBadge}</div>
                        </div>
                        ${resource.user ? `
                        <div class="modal-info-row">
                            <div class="modal-label">USER:</div>
                            <div class="modal-value">${resource.user}</div>
                        </div>
                        ` : ''}
                        ${resource.gpuType ? `
                        <div class="modal-info-row">
                            <div class="modal-label">GPU TYPE:</div>
                            <div class="modal-value">${resource.gpuType}</div>
                        </div>
                        ` : ''}
                    </div>

                    <div class="modal-section">
                        <div class="modal-section-title">▸ HOST STATUS</div>
                        <div class="modal-info-row">
                            <div class="modal-label">HOST STATUS:</div>
                            <div class="modal-value">${resource.status}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">UTILIZATION:</div>
                            <div class="modal-value">${resource.utilization}%</div>
                        </div>
                    </div>
                </div>
            `;

            // Column 2: All load metrics combined
            let column2 = '<div>';
            if (resource.load && Object.keys(resource.load).length > 0) {
                const load = resource.load;
                column2 += `
                    <div class="modal-section">
                        <div class="modal-section-title">▸ LOAD METRICS</div>
                        <div class="bar-graph">
                            ${load.r15s !== undefined ? createBarGraph('15s', load.r15s, 100) : ''}
                            ${load.r1m !== undefined ? createBarGraph('1min', load.r1m, 100) : ''}
                            ${load.r15m !== undefined ? createBarGraph('15min', load.r15m, 100) : ''}
                            ${load.ut !== undefined ? createBarGraph('CPU %', load.ut, 100) : ''}
                            ${load.mem !== undefined ? createBarGraph('Memory', load.mem, 4000000) : ''}
                            ${load.io !== undefined ? createBarGraph('I/O', load.io, 1000) : ''}
                            ${load.tmp !== undefined ? createBarGraph('Temp', load.tmp / 1000, 400) : ''}
                        </div>
                    </div>
                `;
            }
            column2 += '</div>';

            modalContent.innerHTML = column1 + column2;
            modalOverlay.classList.add('visible');
        }

        function closeModal() {
            modalOverlay.classList.remove('visible');
        }

        // Click anywhere on modal or overlay to close
        modalOverlay.addEventListener('click', closeModal);
        modal.addEventListener('click', closeModal);

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const gridX = Math.floor(mouseX / PIXEL_SIZE);
            const gridY = Math.floor(mouseY / PIXEL_SIZE);

            const resource = resources.find(r => r.x === gridX && r.y === gridY);

            if (resource) {
                showModal(resource);
            }
        });

        // Start
        init();
    </script>
</body>
</html>
