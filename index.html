<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Resource Visualization</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        #canvas-container {
            position: absolute;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        /* Border overlay - always drawn on top of canvas */
        #canvas-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00ff00;
            pointer-events: none;
            z-index: 5;
        }

        #canvas-container canvas {
            display: block;
            cursor: grab;
        }

        #canvas-container.dragging canvas {
            cursor: grabbing;
        }

        .resize-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border: 2px solid #000;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        #canvas-container:hover .resize-handle {
            opacity: 0.7;
        }

        .resize-handle:hover {
            opacity: 1 !important;
            transform: scale(1.2);
        }

        .resize-handle.top-left {
            top: -10px;
            left: -10px;
            cursor: nwse-resize;
        }

        .resize-handle.top-right {
            top: -10px;
            right: -10px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-left {
            bottom: -10px;
            left: -10px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -10px;
            right: -10px;
            cursor: nwse-resize;
        }

        #zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.8);
        }

        .zoom-button:hover {
            background: #00ff00;
            color: #000;
        }

        .zoom-button:active {
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            transform: translate(2px, 2px);
        }

        #zoom-level {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            display: flex;
            align-items: center;
            cursor: pointer;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.8);
        }

        #zoom-level:hover {
            background: #00ff00;
            color: #000;
        }

        #tooltip {
            position: fixed;
            left: 20px;
            padding: 16px 20px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            line-height: 1.8;
            color: #00ff00;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            white-space: nowrap;
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip.bottom {
            bottom: 20px;
        }

        #tooltip.top {
            top: 20px;
        }

        #tooltip .label {
            color: #ffff00;
            text-shadow: 0 0 5px rgba(255, 255, 0, 0.7);
        }

        #tooltip .value {
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.7);
        }

        #tooltip .idle {
            color: #ff00ff;
            text-shadow: 0 0 5px rgba(255, 0, 255, 0.7);
        }

        #help {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 180px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            line-height: 2;
            color: #00ff00;
            z-index: 999;
            transition: width 0.3s ease-out;
            overflow: hidden;
        }

        #help.expanded {
            width: 300px;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 180px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            line-height: 2;
            color: #00ff00;
            z-index: 999;
            transition: width 0.3s ease-out;
            overflow: hidden;
        }

        #legend.expanded {
            width: 350px;
            max-height: calc(100vh - 80px);  /* Stop short of zoom controls at bottom */
        }

        #help-title {
            color: #ffff00;
            text-align: center;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            white-space: nowrap;
        }

        #help-title:hover {
            background: #00ff00;
            color: #1a1a2e;
        }

        #help-title::after {
            content: ' [?]';
            color: #00ff00;
            font-size: 8px;
        }

        #help-title:hover::after {
            color: #1a1a2e;
        }

        #help-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }

        #help.expanded #help-content {
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            opacity: 1;
        }

        #help-content::-webkit-scrollbar {
            width: 8px;
        }

        #help-content::-webkit-scrollbar-track {
            background: #0f0f1e;
        }

        #help-content::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        .help-section {
            padding: 16px;
            border-top: 2px solid #00ff00;
        }

        .help-section-title {
            color: #00ffff;
            margin-bottom: 8px;
            font-size: 9px;
        }

        .help-item {
            display: flex;
            gap: 12px;
            margin-bottom: 6px;
            font-size: 8px;
            line-height: 1.6;
        }

        .help-key {
            color: #ffff00;
            min-width: 60px;
            flex-shrink: 0;
        }

        .help-desc {
            color: #00ff00;
        }

        #legend-title {
            color: #ffff00;
            text-align: center;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            white-space: nowrap;
        }

        #legend-title:hover {
            background: #00ff00;
            color: #1a1a2e;
        }

        #legend-title::after {
            content: ' [L]';
            color: #00ff00;
            font-size: 8px;
        }

        #legend-title:hover::after {
            color: #1a1a2e;
        }

        #legend-content {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }

        #legend.expanded #legend-content {
            max-height: calc(100vh - 150px);  /* Account for title, current-mode, and zoom controls */
            overflow-y: auto;
            opacity: 1;
        }

        #current-layout {
            padding: 12px 16px;
            border-top: 2px solid #00ff00;
            text-align: center;
            color: #ffff00;
            font-size: 9px;
            background: rgba(255, 255, 0, 0.1);
        }

        #current-mode {
            padding: 12px 16px;
            border-top: 2px solid #00ff00;
            text-align: center;
            color: #00ffff;
            font-size: 9px;
            background: rgba(0, 255, 255, 0.1);
        }

        #legend-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 16px;
            border-top: 2px solid #00ff00;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 2px solid #00ff00;
            flex-shrink: 0;
        }

        .legend-user {
            color: #00ffff;
            word-break: break-all;
        }

        .legend-count {
            color: #ff00ff;
            margin-left: auto;
            flex-shrink: 0;
        }

        #legend-content::-webkit-scrollbar {
            width: 8px;
        }

        #legend-content::-webkit-scrollbar-track {
            background: #0f0f1e;
        }

        #legend-content::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        /* Modal dialog */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #modal-overlay.visible {
            display: flex;
        }

        #modal {
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 12px 12px 0px rgba(0, 0, 0, 0.9);
            padding: 24px;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: 'Press Start 2P', monospace;
            color: #00ff00;
        }

        #modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #00ff00;
        }

        #modal-title {
            font-size: 12px;
            color: #ffff00;
        }

        #modal-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 40px;
        }

        @media (max-width: 768px) {
            #modal {
                max-width: 90vw;
                width: 90vw;
            }

            #modal-content {
                grid-template-columns: 1fr;
            }
        }


        .modal-section {
            margin-bottom: 20px;
        }

        .modal-section-title {
            color: #00ffff;
            font-size: 10px;
            margin-bottom: 10px;
        }

        .modal-info-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 8px;
            line-height: 1.6;
        }

        .modal-label {
            color: #ffff00;
            min-width: 100px;
        }

        .modal-value {
            color: #00ff00;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border: 2px solid;
            font-size: 8px;
        }

        .status-badge.in-use {
            border-color: #44ff44;
            color: #44ff44;
        }

        .status-badge.idle {
            border-color: #ff00ff;
            color: #ff00ff;
        }

        .bar-graph {
            margin-top: 8px;
        }

        .bar-graph-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 8px;
        }

        .bar-graph-label {
            color: #ffff00;
            min-width: 60px;
        }

        .bar-graph-container {
            flex: 1;
            height: 16px;
            background: #0a0a1a;
            border: 2px solid #00ff00;
            position: relative;
        }

        .bar-graph-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #44ff44);
            transition: width 0.3s ease;
        }

        .bar-graph-value {
            color: #00ffff;
            min-width: 60px;
            text-align: right;
        }

        .type-icon {
            font-size: 24px;
            line-height: 1;
        }

        #modal::-webkit-scrollbar {
            width: 8px;
        }

        #modal::-webkit-scrollbar-track {
            background: #0f0f1e;
        }

        #modal::-webkit-scrollbar-thumb {
            background: #00ff00;
        }

        /* Navigation arrows */
        .modal-nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #00ff00;
            cursor: pointer;
            user-select: none;
            z-index: 2001;
            transition: all 0.2s;
        }

        .modal-nav-arrow:hover {
            background: #00ff00;
            color: #1a1a2e;
            box-shadow: 12px 12px 0px rgba(0, 0, 0, 0.9);
        }

        .modal-nav-arrow.visible {
            display: flex;
        }

        #modal-nav-left {
            left: 20px;
        }

        #modal-nav-right {
            right: 20px;
        }

        /* Time Travel Panel */
        #time-travel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            background: #1a1a2e;
            border: 4px solid #00ff00;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.8);
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
            line-height: 2;
            color: #00ff00;
            z-index: 999;
            transition: all 0.3s ease-out;
            overflow: hidden;
        }

        #time-travel.expanded {
            min-width: 400px;
        }

        #time-travel-title {
            color: #ffff00;
            text-align: center;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            white-space: nowrap;
        }

        #time-travel-title:hover {
            background: #00ff00;
            color: #1a1a2e;
        }

        #time-travel-title::after {
            content: ' [T]';
            color: #00ff00;
            font-size: 8px;
        }

        #time-travel-title:hover::after {
            color: #1a1a2e;
        }

        #time-travel-content {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }

        #time-travel.expanded #time-travel-content {
            max-height: 200px;
            opacity: 1;
        }

        #time-travel-display {
            padding: 12px 16px;
            border-top: 2px solid #00ff00;
            text-align: center;
            font-size: 10px;
        }

        #time-travel-timestamp {
            color: #00ffff;
        }

        #time-travel-timestamp.live {
            color: #ff4444;
        }

        #time-travel-slider-container {
            padding: 8px 16px;
        }

        #time-travel-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #0a0a1a;
            border: 2px solid #00ff00;
            outline: none;
        }

        #time-travel-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff00;
            cursor: pointer;
            border: 2px solid #ffff00;
        }

        #time-travel-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00ff00;
            cursor: pointer;
            border: 2px solid #ffff00;
        }

        #time-travel-range {
            display: flex;
            justify-content: space-between;
            font-size: 7px;
            color: #666;
            margin-top: 4px;
        }

        #time-travel-controls {
            padding: 12px 16px;
            border-top: 2px solid #00ff00;
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .time-travel-button {
            height: 40px;
            background: #1a1a2e;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            padding: 0 10px;
            cursor: pointer;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-travel-button:hover {
            background: #00ff00;
            color: #1a1a2e;
        }

        .time-travel-button:active {
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        .time-travel-button.active {
            background: #00ff00;
            color: #1a1a2e;
        }

        .time-travel-live {
            color: #ff4444;
            border-color: #ff4444;
        }

        .time-travel-live:hover {
            background: #ff4444;
            color: #1a1a2e;
        }

        .time-travel-live.active {
            background: #ff4444;
            color: #1a1a2e;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #time-travel-speed {
            height: 40px;
            background: #1a1a2e;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            padding: 0 8px;
            cursor: pointer;
        }

        #time-travel-speed option {
            background: #1a1a2e;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="grid"></canvas>
        <div class="resize-handle top-left" data-corner="top-left"></div>
        <div class="resize-handle top-right" data-corner="top-right"></div>
        <div class="resize-handle bottom-left" data-corner="bottom-left"></div>
        <div class="resize-handle bottom-right" data-corner="bottom-right"></div>
    </div>
    <div id="tooltip" class="bottom"></div>

    <div id="help">
        <div id="help-title">HELP</div>
        <div id="help-content">
            <div class="help-section">
                <div class="help-section-title">NAVIGATION</div>
                <div class="help-item">
                    <div class="help-key">CLICK+DRAG</div>
                    <div class="help-desc">Move canvas</div>
                </div>
                <div class="help-item">
                    <div class="help-key">CLICK</div>
                    <div class="help-desc">View resource details</div>
                </div>
                <div class="help-item">
                    <div class="help-key">ARROWS</div>
                    <div class="help-desc">Navigate in modal</div>
                </div>
                <div class="help-item">
                    <div class="help-key">ESC</div>
                    <div class="help-desc">Close modal</div>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">ZOOM</div>
                <div class="help-item">
                    <div class="help-key">+ / -</div>
                    <div class="help-desc">Zoom in/out</div>
                </div>
                <div class="help-item">
                    <div class="help-key">CLICK %</div>
                    <div class="help-desc">Reset to 100%</div>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">RESIZE</div>
                <div class="help-item">
                    <div class="help-key">CORNERS</div>
                    <div class="help-desc">Drag to resize</div>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">COLOR MODES</div>
                <div class="help-item">
                    <div class="help-key">1</div>
                    <div class="help-desc">By User</div>
                </div>
                <div class="help-item">
                    <div class="help-key">2</div>
                    <div class="help-desc">By Hostname</div>
                </div>
                <div class="help-item">
                    <div class="help-key">3</div>
                    <div class="help-desc">By Row</div>
                </div>
                <div class="help-item">
                    <div class="help-key">4</div>
                    <div class="help-desc">By Hardware</div>
                </div>
                <div class="help-item">
                    <div class="help-key">5</div>
                    <div class="help-desc">By GPU Type</div>
                </div>
                <div class="help-item">
                    <div class="help-key">6</div>
                    <div class="help-desc">By Utilization</div>
                </div>
                <div class="help-item">
                    <div class="help-key">7</div>
                    <div class="help-desc">By Slot Status</div>
                </div>
                <div class="help-item">
                    <div class="help-key">8</div>
                    <div class="help-desc">By Host Status</div>
                </div>
                <div class="help-item">
                    <div class="help-key">9</div>
                    <div class="help-desc">By Free Memory</div>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">LAYOUT MODES</div>
                <div class="help-item">
                    <div class="help-key">SHIFT+1</div>
                    <div class="help-desc">Linear</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+2</div>
                    <div class="help-desc">Rack Topology</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+3</div>
                    <div class="help-desc">Hardware Groups</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+4</div>
                    <div class="help-desc">User Territories</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+5</div>
                    <div class="help-desc">Job Grouping</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+6</div>
                    <div class="help-desc">Idle Compression</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+7</div>
                    <div class="help-desc">Hilbert Curve</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+8</div>
                    <div class="help-desc">Spiral</div>
                </div>
                <div class="help-item">
                    <div class="help-key">SHIFT+9</div>
                    <div class="help-desc">Radial Sunburst</div>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">PANELS</div>
                <div class="help-item">
                    <div class="help-key">L</div>
                    <div class="help-desc">Toggle legend</div>
                </div>
                <div class="help-item">
                    <div class="help-key">T</div>
                    <div class="help-desc">Toggle time travel</div>
                </div>
                <div class="help-item">
                    <div class="help-key">?</div>
                    <div class="help-desc">Toggle this help</div>
                </div>
            </div>
        </div>
    </div>

    <div id="zoom-controls">
        <button class="zoom-button" id="zoom-out" title="Zoom Out (-)">-</button>
        <div id="zoom-level">100%</div>
        <button class="zoom-button" id="zoom-in" title="Zoom In (+)">+</button>
    </div>
    <div id="legend">
        <div id="legend-title">LEGEND</div>
        <div id="legend-content">
            <div id="current-layout"></div>
            <div id="current-mode"></div>
            <div id="legend-items"></div>
        </div>
    </div>

    <div id="time-travel">
        <div id="time-travel-title">TIME TRAVEL</div>
        <div id="time-travel-content">
            <div id="time-travel-display"><span id="time-travel-timestamp">LIVE</span></div>
            <div id="time-travel-slider-container">
                <input type="range" id="time-travel-slider" min="0" max="100" value="100">
                <div id="time-travel-range">
                    <span id="time-travel-first"></span>
                    <span id="time-travel-last"></span>
                </div>
            </div>
            <div id="time-travel-controls">
                <button id="time-travel-prev" class="time-travel-button" title="Previous snapshot">|&lt;</button>
                <button id="time-travel-play" class="time-travel-button" title="Play/Pause">&#9654;</button>
                <button id="time-travel-loop" class="time-travel-button" title="Loop playback" style="font-size: 16px;">&#8635;</button>
                <button id="time-travel-next" class="time-travel-button" title="Next snapshot">&gt;|</button>
                <select id="time-travel-speed">
                    <option value="100">10e2x</option>
                    <option value="1000" selected>10e3x</option>
                    <option value="10000">10e4x</option>
                    <option value="100000">10e5x</option>
                    <option value="1000000">10e6x</option>
                    <option value="10000000">10e7x</option>
                </select>
                <button id="time-travel-live" class="time-travel-button time-travel-live active" title="Return to LIVE">LIVE</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div id="modal">
            <div id="modal-header">
                <div id="modal-title">RESOURCE DETAILS</div>
                <div id="modal-status"></div>
            </div>
            <div id="modal-content"></div>
        </div>
    </div>

    <div id="modal-nav-left" class="modal-nav-arrow">◀</div>
    <div id="modal-nav-right" class="modal-nav-arrow">▶</div>

    <script>
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');

        // Configuration
        const PIXEL_SIZE = 8; // Size of each square pixel

        // Canvas container state
        let canvasX = 0;
        let canvasY = 0;
        let canvasWidth = 1200;    // Default size
        let canvasHeight = 800;

        // Zoom and pan
        let zoomLevel = 1.0;
        let panOffsetX = 0;
        let panOffsetY = 0;

        // Interaction state
        let isDragging = false;
        let isResizing = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartCanvasX = 0;
        let dragStartCanvasY = 0;
        let dragStartCanvasWidth = 0;
        let dragStartCanvasHeight = 0;
        let resizeHandle = null;
        let clickStartX = 0;
        let clickStartY = 0;
        let lastTouchDistance = 0;

        // Constants
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_STEP = 0.1;
        const MIN_CANVAS_SIZE = 200;
        const PRELOAD_BUFFER = 3;

        // Time travel state
        let timeTravelMode = false;
        let timeTravelTimestamp = null;
        let timeTravelPlaying = false;
        let timeTravelLoop = false;
        let timeTravelSpeed = 1000;
        let timeTravelExpanded = false;
        let availableTimepoints = null;
        let currentTimepointIndex = 0;
        let preloadedSnapshots = new Map();
        let playbackAnimationId = null;
        let lastPlaybackTime = 0;

        // URL State Management
        function saveStateToURL() {
            const state = {
                x: Math.round(canvasX),
                y: Math.round(canvasY),
                w: Math.round(canvasWidth),
                ht: Math.round(canvasHeight),
                z: zoomLevel.toFixed(2),
                m: currentColorMode,
                ly: currentLayoutMode,
                l: legendExpanded ? 1 : 0,
                h: helpExpanded ? 1 : 0,
                te: timeTravelExpanded ? 1 : 0
            };

            // Only add time travel state if not in LIVE mode
            if (timeTravelMode && timeTravelTimestamp) {
                state.tt = timeTravelTimestamp;
                state.ts = timeTravelSpeed;
            }

            const hash = Object.entries(state)
                .map(([key, value]) => `${key}=${value}`)
                .join('&');

            // Update URL without triggering page reload
            history.replaceState(null, '', `#${hash}`);
        }

        function loadStateFromURL() {
            const hash = window.location.hash.substring(1); // Remove '#'
            if (!hash) return false;

            const params = new URLSearchParams(hash);

            if (params.has('x')) canvasX = parseFloat(params.get('x'));
            if (params.has('y')) canvasY = parseFloat(params.get('y'));
            if (params.has('w')) canvasWidth = parseFloat(params.get('w'));
            if (params.has('ht')) canvasHeight = parseFloat(params.get('ht'));
            if (params.has('z')) zoomLevel = parseFloat(params.get('z'));
            if (params.has('m')) currentColorMode = parseInt(params.get('m'));
            if (params.has('ly')) currentLayoutMode = parseInt(params.get('ly'));
            if (params.has('l')) legendExpanded = params.get('l') === '1';
            if (params.has('h')) helpExpanded = params.get('h') === '1';
            if (params.has('te')) timeTravelExpanded = params.get('te') === '1';
            if (params.has('tt')) {
                timeTravelTimestamp = parseInt(params.get('tt'));
                timeTravelMode = true;
            }
            if (params.has('ts')) timeTravelSpeed = parseFloat(params.get('ts'));

            return true;
        }

        let gridWidth, gridHeight;
        let resources = [];
        let userColorMap = new Map();

        // Color mode management
        const MODE_DESCRIPTIONS = [
            'By User',
            'By Hostname',
            'By Row',
            'By Hardware',
            'By GPU Type',
            'By Utilization',
            'By Slot Status',
            'By Host Status',
            'By Free Memory'
        ];

        let currentColorMode = 1;
        let colorStrategies = [];

        let currentLayoutMode = 1;
        let layoutStrategies = [];

        // Resource model
        class Resource {
            constructor(hostname, type, index, user, hostData, hardwareGroup) {
                this.hostname = hostname;
                this.type = type; // 'cpu' or 'gpu'
                this.index = index; // Index within the host
                this.user = user || null; // Username or null if idle
                this.x = 0; // Grid position
                this.y = 0;

                // Additional metadata from host
                this.gpuType = hostData?.gpu_type || null;
                this.utilization = hostData?.utilization || 0;
                this.status = hostData?.status || 'unknown';
                this.load = hostData?.load || {};
                this.hardwareGroup = hardwareGroup || 'Unknown';

                // Job info (populated later from raw data)
                this.jobId = null;
                this.jobName = null;
            }

            get isIdle() {
                return !this.user || this.user === '';
            }

            get row() {
                // Extract row prefix (e.g., "h04" from "h04u08")
                const match = this.hostname.match(/^([a-z]+\d+)/);
                return match ? match[1] : this.hostname;
            }
        }

        // Layout strategy interface
        class LayoutStrategy {
            getName() {
                throw new Error('getName() must be implemented');
            }
            layout(resources, gridWidth, gridHeight) {
                throw new Error('layout() must be implemented');
            }
        }

        // Linear layout grouped by hostname
        class HostnameHierarchyLayout extends LayoutStrategy {
            getName() {
                return 'LINEAR';
            }
            layout(resources, gridWidth, gridHeight) {
                // Group resources by hostname
                const hostGroups = new Map();
                resources.forEach(resource => {
                    if (!hostGroups.has(resource.hostname)) {
                        hostGroups.set(resource.hostname, []);
                    }
                    hostGroups.get(resource.hostname).push(resource);
                });

                // Sort hostnames alphabetically for spatial proximity
                const sortedHostnames = Array.from(hostGroups.keys()).sort();

                // Calculate positions
                let x = 0, y = 0;
                const maxWidth = gridWidth;

                sortedHostnames.forEach(hostname => {
                    const hostResources = hostGroups.get(hostname);

                    // Place all resources from this host together
                    hostResources.forEach((resource, idx) => {
                        resource.x = x;
                        resource.y = y;

                        x++;
                        if (x >= maxWidth) {
                            x = 0;
                            y++;
                        }
                    });

                    // Add small gap between hosts (optional)
                    // x++;
                    // if (x >= maxWidth) {
                    //     x = 0;
                    //     y++;
                    // }
                });
            }
        }

        // User-based layout
        class UserGroupLayout extends LayoutStrategy {
            getName() {
                return 'BY USER';
            }
            layout(resources, gridWidth, gridHeight) {
                // Group resources by user
                const userGroups = new Map();
                resources.forEach(resource => {
                    const user = resource.user || 'idle';
                    if (!userGroups.has(user)) {
                        userGroups.set(user, []);
                    }
                    userGroups.get(user).push(resource);
                });

                // Sort users alphabetically
                const sortedUsers = Array.from(userGroups.keys()).sort();

                // Calculate positions
                let x = 0, y = 0;
                const maxWidth = gridWidth;

                sortedUsers.forEach(user => {
                    const userResources = userGroups.get(user);

                    userResources.forEach(resource => {
                        resource.x = x;
                        resource.y = y;

                        x++;
                        if (x >= maxWidth) {
                            x = 0;
                            y++;
                        }
                    });
                });
            }
        }

        // Rack topology layout - maps hostnames to physical rack positions
        class RackTopologyLayout extends LayoutStrategy {
            getName() {
                return 'RACK';
            }

            parseHostname(hostname) {
                // Parse "h04u08" -> { row: "h04", unit: 8 }
                const match = hostname.match(/^([a-z]+\d+)u(\d+)$/i);
                if (match) {
                    return { row: match[1].toLowerCase(), unit: parseInt(match[2]) };
                }
                return null;
            }

            layout(resources, gridWidth, gridHeight) {
                // Group resources by hostname
                const hostGroups = new Map();
                resources.forEach(resource => {
                    if (!hostGroups.has(resource.hostname)) {
                        hostGroups.set(resource.hostname, []);
                    }
                    hostGroups.get(resource.hostname).push(resource);
                });

                // Parse hostnames and group by row
                const rowMap = new Map(); // row -> [{hostname, unit, resources}]
                hostGroups.forEach((hostResources, hostname) => {
                    const parsed = this.parseHostname(hostname);
                    if (parsed) {
                        if (!rowMap.has(parsed.row)) {
                            rowMap.set(parsed.row, []);
                        }
                        rowMap.get(parsed.row).push({
                            hostname,
                            unit: parsed.unit,
                            resources: hostResources
                        });
                    } else {
                        // Fallback for unparseable hostnames
                        if (!rowMap.has('other')) {
                            rowMap.set('other', []);
                        }
                        rowMap.get('other').push({
                            hostname,
                            unit: 0,
                            resources: hostResources
                        });
                    }
                });

                // Sort rows alphabetically
                const sortedRows = Array.from(rowMap.keys()).sort();

                // Find max slots per host and max units per row
                let maxCpuSlots = 0;
                let maxGpuSlots = 0;
                hostGroups.forEach(hostResources => {
                    const cpuCount = hostResources.filter(r => r.type === 'cpu').length;
                    const gpuCount = hostResources.filter(r => r.type === 'gpu').length;
                    maxCpuSlots = Math.max(maxCpuSlots, cpuCount);
                    maxGpuSlots = Math.max(maxGpuSlots, gpuCount);
                });

                // Each host is one row: GPU slots first, then CPU slots
                const hostWidth = maxGpuSlots + maxCpuSlots;

                // Calculate actual height of each rack (number of hosts)
                const rackHeights = sortedRows.map(rowName => rowMap.get(rowName).length);
                const totalHosts = rackHeights.reduce((a, b) => a + b, 0);

                // Aim for roughly square aspect ratio
                const numRacks = sortedRows.length;
                const avgRackHeight = totalHosts / numRacks;
                const racksPerRow = Math.max(1, Math.ceil(Math.sqrt(numRacks * (avgRackHeight / hostWidth))));

                // Layout racks in a grid, tracking actual heights per row
                const rowHeights = []; // Track max height of each grid row
                const rackPositions = []; // Store {gridCol, gridRow} for each rack

                sortedRows.forEach((rowName, rackIndex) => {
                    const gridCol = rackIndex % racksPerRow;
                    const gridRow = Math.floor(rackIndex / racksPerRow);
                    rackPositions.push({ gridCol, gridRow });

                    // Track max height for this grid row
                    const rackHeight = rackHeights[rackIndex];
                    if (!rowHeights[gridRow]) rowHeights[gridRow] = 0;
                    rowHeights[gridRow] = Math.max(rowHeights[gridRow], rackHeight);
                });

                // Calculate cumulative Y offsets for each grid row
                const rowYOffsets = [0];
                for (let i = 0; i < rowHeights.length - 1; i++) {
                    rowYOffsets.push(rowYOffsets[i] + rowHeights[i]);
                }

                // Layout each rack
                sortedRows.forEach((rowName, rackIndex) => {
                    const hosts = rowMap.get(rowName);
                    hosts.sort((a, b) => a.unit - b.unit);

                    const { gridCol, gridRow } = rackPositions[rackIndex];
                    const rackX = gridCol * hostWidth;
                    const rackY = rowYOffsets[gridRow];

                    hosts.forEach((host, hostIndex) => {
                        const cpuResources = host.resources.filter(r => r.type === 'cpu');
                        const gpuResources = host.resources.filter(r => r.type === 'gpu');

                        // Place GPU slots first (left side of host line)
                        gpuResources.forEach((resource, idx) => {
                            resource.x = rackX + idx;
                            resource.y = rackY + hostIndex;
                        });

                        // Place CPU slots after GPUs (right side of host line)
                        cpuResources.forEach((resource, idx) => {
                            resource.x = rackX + maxGpuSlots + idx;
                            resource.y = rackY + hostIndex;
                        });
                    });
                });
            }
        }

        // Hardware group islands layout - clusters by hardware type
        class HardwareGroupLayout extends LayoutStrategy {
            getName() {
                return 'HARDWARE';
            }

            layout(resources, gridWidth, gridHeight) {
                // Group resources by hardware group, then by hostname
                const groupMap = new Map(); // hardwareGroup -> hostname -> resources[]
                resources.forEach(resource => {
                    const group = resource.hardwareGroup || 'Unknown';
                    if (!groupMap.has(group)) {
                        groupMap.set(group, new Map());
                    }
                    const hostMap = groupMap.get(group);
                    if (!hostMap.has(resource.hostname)) {
                        hostMap.set(resource.hostname, []);
                    }
                    hostMap.get(resource.hostname).push(resource);
                });

                // Sort groups by name
                const sortedGroups = Array.from(groupMap.keys()).sort();

                // Find max slots per host
                let maxCpuSlots = 0;
                let maxGpuSlots = 0;
                resources.forEach(resource => {
                    // Count per hostname would be better but this is simpler
                });
                groupMap.forEach(hostMap => {
                    hostMap.forEach(hostResources => {
                        const cpuCount = hostResources.filter(r => r.type === 'cpu').length;
                        const gpuCount = hostResources.filter(r => r.type === 'gpu').length;
                        maxCpuSlots = Math.max(maxCpuSlots, cpuCount);
                        maxGpuSlots = Math.max(maxGpuSlots, gpuCount);
                    });
                });

                const hostWidth = maxGpuSlots + maxCpuSlots;

                // Calculate heights for each group
                const groupHeights = sortedGroups.map(group => groupMap.get(group).size);
                const totalHosts = groupHeights.reduce((a, b) => a + b, 0);

                // Aim for roughly square aspect ratio
                const numGroups = sortedGroups.length;
                const avgGroupHeight = totalHosts / numGroups;
                const groupsPerRow = Math.max(1, Math.ceil(Math.sqrt(numGroups * (avgGroupHeight / hostWidth))));

                // Layout groups in a grid, tracking actual heights per row
                const rowHeights = [];
                const groupPositions = [];

                sortedGroups.forEach((groupName, groupIndex) => {
                    const gridCol = groupIndex % groupsPerRow;
                    const gridRow = Math.floor(groupIndex / groupsPerRow);
                    groupPositions.push({ gridCol, gridRow });

                    const groupHeight = groupHeights[groupIndex];
                    if (!rowHeights[gridRow]) rowHeights[gridRow] = 0;
                    rowHeights[gridRow] = Math.max(rowHeights[gridRow], groupHeight);
                });

                // Calculate cumulative Y offsets
                const rowYOffsets = [0];
                for (let i = 0; i < rowHeights.length - 1; i++) {
                    rowYOffsets.push(rowYOffsets[i] + rowHeights[i]);
                }

                // Layout each group
                sortedGroups.forEach((groupName, groupIndex) => {
                    const hostMap = groupMap.get(groupName);
                    const sortedHostnames = Array.from(hostMap.keys()).sort();

                    const { gridCol, gridRow } = groupPositions[groupIndex];
                    const groupX = gridCol * hostWidth;
                    const groupY = rowYOffsets[gridRow];

                    sortedHostnames.forEach((hostname, hostIndex) => {
                        const hostResources = hostMap.get(hostname);
                        const cpuResources = hostResources.filter(r => r.type === 'cpu');
                        const gpuResources = hostResources.filter(r => r.type === 'gpu');

                        // Place GPU slots first
                        gpuResources.forEach((resource, idx) => {
                            resource.x = groupX + idx;
                            resource.y = groupY + hostIndex;
                        });

                        // Place CPU slots after GPUs
                        cpuResources.forEach((resource, idx) => {
                            resource.x = groupX + maxGpuSlots + idx;
                            resource.y = groupY + hostIndex;
                        });
                    });
                });
            }
        }

        // User territories layout - treemap-style by user
        class UserTerritoriesLayout extends LayoutStrategy {
            getName() {
                return 'USERS';
            }

            layout(resources, gridWidth, gridHeight) {
                // Separate idle and active resources
                const idleResources = [];
                const userMap = new Map(); // user -> resources[]

                resources.forEach(resource => {
                    if (!resource.user || resource.user === '') {
                        idleResources.push(resource);
                    } else {
                        if (!userMap.has(resource.user)) {
                            userMap.set(resource.user, []);
                        }
                        userMap.get(resource.user).push(resource);
                    }
                });

                // Sort users by slot count (descending) for better packing
                const sortedUsers = Array.from(userMap.keys()).sort((a, b) => {
                    return userMap.get(b).length - userMap.get(a).length;
                });

                // Use full canvas width
                const targetWidth = gridWidth;

                // Simple row-based treemap: fill rows left to right
                let currentX = 0;
                let currentY = 0;
                let rowHeight = 0;
                let maxX = 0;

                sortedUsers.forEach(user => {
                    const userResources = userMap.get(user);
                    const slotCount = userResources.length;

                    // Calculate rectangle dimensions for this user
                    const userWidth = Math.ceil(Math.sqrt(slotCount * 1.5));

                    // Check if we need to wrap to next row
                    if (currentX + userWidth > targetWidth && currentX > 0) {
                        currentX = 0;
                        currentY += rowHeight;
                        rowHeight = 0;
                    }

                    // Place resources in a rectangle for this user
                    let localX = 0;
                    let localY = 0;
                    userResources.forEach((resource) => {
                        resource.x = currentX + localX;
                        resource.y = currentY + localY;

                        localX++;
                        if (localX >= userWidth) {
                            localX = 0;
                            localY++;
                        }
                    });

                    // Update position for next user
                    const actualHeight = Math.ceil(slotCount / userWidth);
                    rowHeight = Math.max(rowHeight, actualHeight);
                    maxX = Math.max(maxX, currentX + userWidth);
                    currentX += userWidth;
                });

                // Place idle slots at the end, filling horizontally across full canvas width
                // Start after the last row of active users
                const idleStartY = currentY + rowHeight;
                let idleX = 0;
                let idleY = idleStartY;

                // Use full canvas width for idle slots
                const idleRowWidth = gridWidth;

                idleResources.forEach((resource) => {
                    resource.x = idleX;
                    resource.y = idleY;

                    idleX++;
                    if (idleX >= idleRowWidth) {
                        idleX = 0;
                        idleY++;
                    }
                });
            }
        }

        // Hilbert curve layout - space-filling curve preserving locality
        class HilbertCurveLayout extends LayoutStrategy {
            getName() {
                return 'HILBERT';
            }

            // Convert 1D index to 2D Hilbert curve coordinates
            hilbertD2xy(n, d) {
                let x = 0, y = 0;
                let s = 1;
                let rx, ry, t = d;

                while (s < n) {
                    rx = 1 & (t / 2);
                    ry = 1 & (t ^ rx);

                    // Rotate quadrant
                    if (ry === 0) {
                        if (rx === 1) {
                            x = s - 1 - x;
                            y = s - 1 - y;
                        }
                        [x, y] = [y, x];
                    }

                    x += s * rx;
                    y += s * ry;
                    t = Math.floor(t / 4);
                    s *= 2;
                }

                return { x, y };
            }

            layout(resources, gridWidth, gridHeight) {
                if (resources.length === 0) return;

                // Sort resources by hostname to keep hosts together
                const sortedResources = [...resources].sort((a, b) => {
                    if (a.hostname !== b.hostname) {
                        return a.hostname.localeCompare(b.hostname);
                    }
                    // Within same host, GPUs first, then CPUs
                    if (a.type !== b.type) {
                        return a.type === 'gpu' ? -1 : 1;
                    }
                    return a.index - b.index;
                });

                // Calculate Hilbert curve order (must be power of 2)
                const n = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(resources.length))));

                // Map each resource to Hilbert curve position
                sortedResources.forEach((resource, idx) => {
                    const { x, y } = this.hilbertD2xy(n, idx);
                    resource.x = x;
                    resource.y = y;
                });
            }
        }

        // Spiral layout - center outward, ordered by utilization
        class SpiralLayout extends LayoutStrategy {
            getName() {
                return 'SPIRAL';
            }

            layout(resources, gridWidth, gridHeight) {
                if (resources.length === 0) return;

                // Sort by utilization (highest first - hot center)
                const sortedResources = [...resources].sort((a, b) => {
                    const utilA = a.user ? (a.utilization || 100) : 0;
                    const utilB = b.user ? (b.utilization || 100) : 0;
                    return utilB - utilA;
                });

                // Generate spiral coordinates
                const size = Math.ceil(Math.sqrt(resources.length));
                const centerX = Math.floor(size / 2);
                const centerY = Math.floor(size / 2);

                // Spiral outward from center
                let x = centerX, y = centerY;
                let dx = 1, dy = 0;
                let segmentLength = 1;
                let segmentPassed = 0;
                let turnsMade = 0;

                sortedResources.forEach((resource, idx) => {
                    resource.x = x;
                    resource.y = y;

                    // Move to next position
                    x += dx;
                    y += dy;
                    segmentPassed++;

                    // Check if we need to turn
                    if (segmentPassed === segmentLength) {
                        segmentPassed = 0;
                        // Rotate direction 90 degrees counter-clockwise
                        [dx, dy] = [-dy, dx];
                        turnsMade++;
                        // Increase segment length every 2 turns
                        if (turnsMade % 2 === 0) {
                            segmentLength++;
                        }
                    }
                });

                // Normalize coordinates to start from 0
                let minX = Infinity, minY = Infinity;
                sortedResources.forEach(r => {
                    minX = Math.min(minX, r.x);
                    minY = Math.min(minY, r.y);
                });
                sortedResources.forEach(r => {
                    r.x -= minX;
                    r.y -= minY;
                });
            }
        }

        // Job grouping layout - groups by job_id to show job footprints
        class JobGroupingLayout extends LayoutStrategy {
            getName() {
                return 'JOBS';
            }

            layout(resources, gridWidth, gridHeight) {
                // Separate resources by job
                const jobMap = new Map(); // jobId -> resources[]
                const idleResources = [];

                resources.forEach(resource => {
                    if (!resource.jobId || resource.jobId === '') {
                        idleResources.push(resource);
                    } else {
                        if (!jobMap.has(resource.jobId)) {
                            jobMap.set(resource.jobId, []);
                        }
                        jobMap.get(resource.jobId).push(resource);
                    }
                });

                // Sort jobs by slot count (descending)
                const sortedJobs = Array.from(jobMap.keys()).sort((a, b) => {
                    return jobMap.get(b).length - jobMap.get(a).length;
                });

                // Use full canvas width
                const targetWidth = gridWidth;

                // Layout jobs as rectangular blocks
                let currentX = 0;
                let currentY = 0;
                let rowHeight = 0;

                sortedJobs.forEach(jobId => {
                    const jobResources = jobMap.get(jobId);
                    const slotCount = jobResources.length;

                    // Calculate rectangle dimensions for this job
                    const jobWidth = Math.ceil(Math.sqrt(slotCount * 1.5));

                    // Check if we need to wrap to next row
                    if (currentX + jobWidth > targetWidth && currentX > 0) {
                        currentX = 0;
                        currentY += rowHeight;
                        rowHeight = 0;
                    }

                    // Place resources in a rectangle for this job
                    let localX = 0;
                    let localY = 0;
                    jobResources.forEach((resource) => {
                        resource.x = currentX + localX;
                        resource.y = currentY + localY;

                        localX++;
                        if (localX >= jobWidth) {
                            localX = 0;
                            localY++;
                        }
                    });

                    // Update position for next job
                    const actualHeight = Math.ceil(slotCount / jobWidth);
                    rowHeight = Math.max(rowHeight, actualHeight);
                    currentX += jobWidth;
                });

                // Place idle slots at the end
                const idleStartY = currentY + rowHeight;
                let idleX = 0;
                let idleY = idleStartY;

                idleResources.forEach((resource) => {
                    resource.x = idleX;
                    resource.y = idleY;

                    idleX++;
                    if (idleX >= gridWidth) {
                        idleX = 0;
                        idleY++;
                    }
                });
            }
        }

        // Radial sunburst layout - concentric rings by hierarchy
        class RadialSunburstLayout extends LayoutStrategy {
            getName() {
                return 'RADIAL SUNBURST';
            }

            layout(resources, gridWidth, gridHeight) {
                // Center of the sunburst
                const centerX = Math.floor(gridWidth / 2);
                const centerY = Math.floor(gridHeight / 2);
                const maxRadius = Math.min(centerX, centerY) - 1;

                // Group by hardware group -> host -> slots
                const hwGroups = new Map(); // hwGroup -> Map(host -> resources[])

                resources.forEach(resource => {
                    const hwGroup = resource.hardwareGroup || 'Unknown';
                    const host = resource.hostname;

                    if (!hwGroups.has(hwGroup)) {
                        hwGroups.set(hwGroup, new Map());
                    }
                    const hostMap = hwGroups.get(hwGroup);
                    if (!hostMap.has(host)) {
                        hostMap.set(host, []);
                    }
                    hostMap.get(host).push(resource);
                });

                // Sort hardware groups by total slot count (largest first)
                const sortedHwGroups = Array.from(hwGroups.entries())
                    .map(([name, hostMap]) => {
                        let totalSlots = 0;
                        hostMap.forEach(slots => totalSlots += slots.length);
                        return { name, hostMap, totalSlots };
                    })
                    .sort((a, b) => b.totalSlots - a.totalSlots);

                const totalSlots = resources.length;

                // Assign angular spans to each hardware group
                let currentAngle = -Math.PI / 2; // Start at top

                sortedHwGroups.forEach(hwGroup => {
                    const groupAngleSpan = (hwGroup.totalSlots / totalSlots) * 2 * Math.PI;

                    // Sort hosts within group by slot count
                    const sortedHosts = Array.from(hwGroup.hostMap.entries())
                        .map(([hostname, slots]) => ({ hostname, slots }))
                        .sort((a, b) => b.slots.length - a.slots.length);

                    // Assign angular spans to each host within the group
                    let hostAngle = currentAngle;

                    sortedHosts.forEach(({ hostname, slots }) => {
                        const hostAngleSpan = (slots.length / hwGroup.totalSlots) * groupAngleSpan;

                        // Separate GPUs and CPUs
                        const gpus = slots.filter(s => s.type === 'gpu');
                        const cpus = slots.filter(s => s.type === 'cpu');

                        // GPUs in inner ring, CPUs in outer ring
                        const innerRadius = maxRadius * 0.3;
                        const outerRadius = maxRadius * 0.95;

                        // Place GPUs in inner portion
                        if (gpus.length > 0) {
                            const gpuRadiusStart = innerRadius;
                            const gpuRadiusEnd = innerRadius + (outerRadius - innerRadius) * 0.4;
                            this.placeInArc(gpus, hostAngle, hostAngleSpan, gpuRadiusStart, gpuRadiusEnd, centerX, centerY);
                        }

                        // Place CPUs in outer portion
                        if (cpus.length > 0) {
                            const cpuRadiusStart = innerRadius + (outerRadius - innerRadius) * 0.45;
                            const cpuRadiusEnd = outerRadius;
                            this.placeInArc(cpus, hostAngle, hostAngleSpan, cpuRadiusStart, cpuRadiusEnd, centerX, centerY);
                        }

                        hostAngle += hostAngleSpan;
                    });

                    currentAngle += groupAngleSpan;
                });
            }

            placeInArc(slots, startAngle, angleSpan, innerRadius, outerRadius, centerX, centerY) {
                if (slots.length === 0) return;

                // Calculate how many rings and slots per ring we need
                const radiusRange = outerRadius - innerRadius;
                const circumference = 2 * Math.PI * ((innerRadius + outerRadius) / 2) * (angleSpan / (2 * Math.PI));

                // Estimate slots that fit in one ring within our angle span
                const slotsPerRing = Math.max(1, Math.floor(circumference));
                const numRings = Math.ceil(slots.length / slotsPerRing);
                const ringSpacing = numRings > 1 ? radiusRange / (numRings - 1) : 0;

                let slotIndex = 0;
                for (let ring = 0; ring < numRings && slotIndex < slots.length; ring++) {
                    const radius = innerRadius + ring * ringSpacing;
                    const slotsInThisRing = Math.min(slotsPerRing, slots.length - slotIndex);
                    const angleStep = slotsInThisRing > 1 ? angleSpan / slotsInThisRing : 0;
                    const angleOffset = slotsInThisRing > 1 ? angleStep / 2 : angleSpan / 2;

                    for (let i = 0; i < slotsInThisRing && slotIndex < slots.length; i++) {
                        const angle = startAngle + angleOffset + i * angleStep;
                        const resource = slots[slotIndex];
                        resource.x = Math.round(centerX + radius * Math.cos(angle));
                        resource.y = Math.round(centerY + radius * Math.sin(angle));
                        slotIndex++;
                    }
                }
            }
        }

        // Idle compression layout - active slots dense at top, idle compressed below
        class IdleCompressionLayout extends LayoutStrategy {
            getName() {
                return 'IDLE COMPRESSION';
            }

            layout(resources, gridWidth, gridHeight) {
                // Separate active and idle slots
                const activeSlots = [];
                const idleSlots = [];

                resources.forEach(resource => {
                    if (resource.user && resource.user !== '') {
                        activeSlots.push(resource);
                    } else {
                        idleSlots.push(resource);
                    }
                });

                // Active slots: pack densely at top, filling full width
                let x = 0;
                let y = 0;

                activeSlots.forEach(resource => {
                    resource.x = x;
                    resource.y = y;
                    x++;
                    if (x >= gridWidth) {
                        x = 0;
                        y++;
                    }
                });

                // Calculate where active section ends
                const activeEndY = (x > 0) ? y + 1 : y;

                // Idle slots: compressed into fewer rows with gaps
                // Use wider spacing to make them visually smaller/less prominent
                const idleStartY = activeEndY + 1; // Gap between sections
                const compressionFactor = 2; // Pack idle slots with gaps

                let idleX = 0;
                let idleY = idleStartY;
                let idleCol = 0;

                idleSlots.forEach((resource, i) => {
                    resource.x = idleX;
                    resource.y = idleY;

                    idleCol++;
                    idleX += compressionFactor; // Skip pixels for compression effect

                    if (idleX >= gridWidth) {
                        idleX = 0;
                        idleCol = 0;
                        idleY++;
                    }
                });
            }
        }

        // Color strategy interface
        class ColorStrategy {
            constructor() {
                this.colorMap = new Map();
            }

            getColor(resource) {
                throw new Error('getColor() must be implemented');
            }

            getLegendItems(resources) {
                throw new Error('getLegendItems() must be implemented');
            }

            initialize(resources) {
                // Override if needed to pre-compute colors
            }
        }

        // Mode 1: By User
        class UserColorStrategy extends ColorStrategy {
            initialize(resources) {
                const users = resources.map(r => r.user).filter(u => u && u !== '');
                const uniqueUsers = Array.from(new Set(users));
                const colors = generateDistinctColors(uniqueUsers.length);

                uniqueUsers.forEach((user, i) => {
                    this.colorMap.set(user, colors[i]);
                });
                this.colorMap.set(null, '#2a2a2a');
                this.colorMap.set('', '#2a2a2a');
            }

            getColor(resource) {
                return this.colorMap.get(resource.user) || this.colorMap.get(null);
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    const key = r.user || 'idle';
                    counts.set(key, (counts.get(key) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => {
                        if (a === 'idle') return 1;
                        if (b === 'idle') return -1;
                        return counts.get(b) - counts.get(a);
                    })
                    .map(key => ({
                        label: key === 'idle' ? 'IDLE' : key,
                        color: this.getColor({ user: key === 'idle' ? null : key }),
                        count: counts.get(key)
                    }));
            }
        }

        // Mode 2: By Hostname
        class HostnameColorStrategy extends ColorStrategy {
            initialize(resources) {
                const hostnames = Array.from(new Set(resources.map(r => r.hostname))).sort();
                const colors = generateRandomColors(hostnames.length);
                hostnames.forEach((hostname, i) => {
                    this.colorMap.set(hostname, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.hostname) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.hostname, (counts.get(r.hostname) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort()
                    .map(hostname => ({
                        label: hostname,
                        color: this.colorMap.get(hostname),
                        count: counts.get(hostname)
                    }));
            }
        }

        // Mode 3: By Row
        class RowColorStrategy extends ColorStrategy {
            initialize(resources) {
                const rows = Array.from(new Set(resources.map(r => r.row))).sort();
                const colors = generateRandomColors(rows.length);
                rows.forEach((row, i) => {
                    this.colorMap.set(row, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.row) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.row, (counts.get(r.row) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort()
                    .map(row => ({
                        label: row,
                        color: this.colorMap.get(row),
                        count: counts.get(row)
                    }));
            }
        }

        // Mode 4: By Hardware Group
        class TypeColorStrategy extends ColorStrategy {
            constructor() {
                super();
                // Generate distinct colors for hardware groups
                const hardwareGroups = [
                    'CPU + T4',
                    'CPU + L4',
                    'CPU + 8GPU L4',
                    '8GPU L4',
                    '4GPU A100',
                    '8GPU H100',
                    '8GPU H200',
                    'GH200',
                    '7GPU L4',
                    'Unknown'
                ];

                const colors = generateDistinctColors(hardwareGroups.length);
                hardwareGroups.forEach((group, idx) => {
                    this.colorMap.set(group, colors[idx]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.hardwareGroup) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.hardwareGroup, (counts.get(r.hardwareGroup) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort()
                    .map(group => ({
                        label: group,
                        color: this.colorMap.get(group),
                        count: counts.get(group)
                    }));
            }
        }

        // Mode 5: By GPU Type
        class GpuTypeColorStrategy extends ColorStrategy {
            initialize(resources) {
                const gpuTypes = Array.from(new Set(resources.map(r => r.gpuType).filter(t => t)));
                const colors = generateDistinctColors(gpuTypes.length + 1);

                gpuTypes.forEach((type, i) => {
                    this.colorMap.set(type, colors[i]);
                });
                this.colorMap.set(null, colors[gpuTypes.length]); // CPU color
            }

            getColor(resource) {
                return this.colorMap.get(resource.gpuType) || this.colorMap.get(null);
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    const key = r.gpuType || 'CPU';
                    counts.set(key, (counts.get(key) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => {
                        if (a === 'CPU') return 1;
                        if (b === 'CPU') return -1;
                        return a.localeCompare(b);
                    })
                    .map(key => ({
                        label: key,
                        color: this.getColor({ gpuType: key === 'CPU' ? null : key }),
                        count: counts.get(key)
                    }));
            }
        }

        // Mode 6: By Utilization (Heat Map)
        class UtilizationColorStrategy extends ColorStrategy {
            initialize(resources) {
                const utils = resources.map(r => r.utilization);
                this.min = Math.min(...utils);
                this.max = Math.max(...utils);
            }

            getColor(resource) {
                return getHeatMapColor(resource.utilization, this.min, this.max);
            }

            getLegendItems(resources) {
                const ranges = [
                    { label: '0-20%', min: 0, max: 20 },
                    { label: '21-40%', min: 21, max: 40 },
                    { label: '41-60%', min: 41, max: 60 },
                    { label: '61-80%', min: 61, max: 80 },
                    { label: '81-100%', min: 81, max: 100 }
                ];

                return ranges.map(range => {
                    const count = resources.filter(r =>
                        r.utilization >= range.min && r.utilization <= range.max
                    ).length;
                    return {
                        label: range.label,
                        color: getHeatMapColor((range.min + range.max) / 2, 0, 100),
                        count: count
                    };
                });
            }
        }

        // Mode 7: By Slot Status (Idle vs In-Use)
        class StatusColorStrategy extends ColorStrategy {
            constructor() {
                super();
                this.colorMap.set(true, '#2a2a2a');  // Idle
                this.colorMap.set(false, '#44ff44'); // In-use
            }

            getColor(resource) {
                return this.colorMap.get(resource.isIdle);
            }

            getLegendItems(resources) {
                const idleCount = resources.filter(r => r.isIdle).length;
                const inUseCount = resources.length - idleCount;

                return [
                    { label: 'IN-USE', color: this.colorMap.get(false), count: inUseCount },
                    { label: 'IDLE', color: this.colorMap.get(true), count: idleCount }
                ];
            }
        }

        // Mode 8: By Host Status
        class HostStatusColorStrategy extends ColorStrategy {
            initialize(resources) {
                const statuses = Array.from(new Set(resources.map(r => r.status)));
                const colors = generateDistinctColors(statuses.length);
                statuses.forEach((status, i) => {
                    this.colorMap.set(status, colors[i]);
                });
            }

            getColor(resource) {
                return this.colorMap.get(resource.status) || '#2a2a2a';
            }

            getLegendItems(resources) {
                const counts = new Map();
                resources.forEach(r => {
                    counts.set(r.status, (counts.get(r.status) || 0) + 1);
                });

                return Array.from(counts.keys())
                    .sort((a, b) => counts.get(b) - counts.get(a))
                    .map(status => ({
                        label: status,
                        color: this.colorMap.get(status),
                        count: counts.get(status)
                    }));
            }
        }

        // Mode 9: By Free Memory
        class MemoryLoadColorStrategy extends ColorStrategy {
            initialize(resources) {
                const mems = resources.map(r => r.load?.mem || 0);
                this.min = 0; // Start at zero
                this.max = Math.max(...mems);
            }

            getColor(resource) {
                const mem = resource.load?.mem || 0;
                // Inverted: low memory (0) = red, high memory = blue
                const normalized = Math.max(0, Math.min(1, (mem - this.min) / (this.max - this.min)));
                const hue = normalized * 240; // 0 = red (low), 240 = blue (high)
                return `hsl(${hue}, 80%, 50%)`;
            }

            getLegendItems(resources) {
                const mems = resources.map(r => r.load?.mem || 0);
                const min = 0; // Start at zero
                const max = Math.max(...mems);
                const range = max - min;
                const step = range / 5;

                const ranges = [];
                for (let i = 0; i < 5; i++) {
                    const rangeMin = min + (step * i);
                    const rangeMax = min + (step * (i + 1));
                    const count = resources.filter(r => {
                        const mem = r.load?.mem || 0;
                        return mem >= rangeMin && mem < (i === 4 ? rangeMax + 1 : rangeMax);
                    }).length;

                    // Inverted color: low = red, high = blue
                    const normalized = ((rangeMin + rangeMax) / 2) / max;
                    const hue = normalized * 240;

                    ranges.push({
                        label: `${formatMemoryGB(rangeMin)}-${formatMemoryGB(rangeMax)} GB`,
                        color: `hsl(${hue}, 80%, 50%)`,
                        count: count
                    });
                }

                return ranges;
            }
        }

        // Helper color generation functions
        function generateDistinctColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                const saturation = 70;
                const lightness = 60;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function generateRandomColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = Math.random() * 360;
                const saturation = 60 + Math.random() * 20;
                const lightness = 50 + Math.random() * 20;
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function getHeatMapColor(value, min, max) {
            if (max === min) return 'hsl(120, 70%, 50%)'; // All same value, use middle color
            const normalized = Math.max(0, Math.min(1, (value - min) / (max - min)));
            const hue = (1 - normalized) * 240; // 240 = blue (low), 0 = red (high)
            return `hsl(${hue}, 80%, 50%)`;
        }

        function formatMemoryGB(memMB, decimals = 1) {
            return (memMB / 1024).toFixed(decimals);
        }

        // Canvas positioning and sizing functions
        function centerCanvas() {
            canvasX = (window.innerWidth - canvasWidth) / 2;
            canvasY = (window.innerHeight - canvasHeight) / 2;
            updateCanvasPosition();
        }

        function updateCanvasPosition() {
            const container = document.getElementById('canvas-container');
            container.style.left = canvasX + 'px';
            container.style.top = canvasY + 'px';
            container.style.width = canvasWidth + 'px';
            container.style.height = canvasHeight + 'px';
        }

        function updateCanvasSize() {
            const canvas = document.getElementById('grid');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            gridWidth = Math.floor(canvasWidth / PIXEL_SIZE);
            gridHeight = Math.floor(canvasHeight / PIXEL_SIZE);
        }

        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('zoom-level');
            zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Generate colors for users
        function generateUserColors(users) {
            const colors = new Map();
            const uniqueUsers = Array.from(new Set(users)).filter(u => u && u !== '');

            uniqueUsers.forEach((user, i) => {
                const hue = (i * 360 / uniqueUsers.length) % 360;
                const saturation = 65 + Math.random() * 15;
                const lightness = 55 + Math.random() * 15;
                colors.set(user, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
            });

            // Color for idle resources
            colors.set(null, '#2a2a2a');
            colors.set('', '#2a2a2a');

            return colors;
        }

        // Convert sparse slot format to array
        function sparseToArray(sparseSlots, totalCount) {
            const array = new Array(totalCount).fill('');
            if (sparseSlots && typeof sparseSlots === 'object' && !Array.isArray(sparseSlots)) {
                for (const [index, user] of Object.entries(sparseSlots)) {
                    const idx = parseInt(index, 10);
                    if (!isNaN(idx) && idx < totalCount) {
                        array[idx] = user;
                    }
                }
            } else if (Array.isArray(sparseSlots)) {
                // Backwards compatibility: if it's already an array, use it directly
                return sparseSlots;
            }
            return array;
        }

        // Time Travel Functions
        function formatTimestamp(unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatRelativeTime(unixTimestamp) {
            const now = Date.now() / 1000;
            const diff = now - unixTimestamp;

            if (diff < 60) return 'Just now';
            if (diff < 3600) return `${Math.floor(diff / 60)} min ago`;
            if (diff < 86400) return `${Math.floor(diff / 3600)} hrs ago`;
            return `${Math.floor(diff / 86400)} days ago`;
        }

        function updateTimeTravelDisplay() {
            const displayEl = document.getElementById('time-travel-timestamp');

            if (!timeTravelMode || !timeTravelTimestamp) {
                displayEl.textContent = 'LIVE';
                displayEl.classList.add('live');
            } else {
                const formatted = formatTimestamp(timeTravelTimestamp);
                const relative = formatRelativeTime(timeTravelTimestamp);
                displayEl.textContent = `${formatted} (${relative})`;
                displayEl.classList.remove('live');
            }
        }

        async function initTimeTravel() {
            try {
                const response = await fetch('/api/timepoints');
                if (!response.ok) {
                    console.error('Failed to fetch timepoints:', response.status);
                    return;
                }
                availableTimepoints = await response.json();
                console.log('Time travel initialized with', availableTimepoints.count, 'timepoints');

                if (availableTimepoints.timestamps && availableTimepoints.timestamps.length > 0) {
                    const slider = document.getElementById('time-travel-slider');
                    slider.min = 0;
                    slider.max = availableTimepoints.timestamps.length - 1;
                    slider.value = slider.max;
                    currentTimepointIndex = availableTimepoints.timestamps.length - 1;

                    // Update range labels
                    document.getElementById('time-travel-first').textContent =
                        formatTimestamp(availableTimepoints.first);
                    document.getElementById('time-travel-last').textContent =
                        formatTimestamp(availableTimepoints.last);

                    updateTimeTravelDisplay();
                } else {
                    console.log('No timepoints available for time travel');
                }
            } catch (error) {
                console.error('Failed to initialize time travel:', error);
            }
        }

        async function loadClusterDataAt(timestamp) {
            // Check preloaded cache first
            if (preloadedSnapshots.has(timestamp)) {
                const data = preloadedSnapshots.get(timestamp);
                processClusterData(data);
                return true;
            }

            try {
                const response = await fetch(`/api/cluster-status/${timestamp}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();

                // Cache for potential replay
                preloadedSnapshots.set(timestamp, data);

                // Limit cache size
                if (preloadedSnapshots.size > 20) {
                    const oldestKey = preloadedSnapshots.keys().next().value;
                    preloadedSnapshots.delete(oldestKey);
                }

                processClusterData(data);
                return true;
            } catch (error) {
                console.error(`Failed to load data for ${timestamp}:`, error);
                return false;
            }
        }

        function processClusterData(data) {
            // Extract resources from hostDetails (same logic as loadClusterData)
            const allResources = [];
            const allUsers = [];

            data.hostDetails.forEach(host => {
                const hardwareGroup = host.hardwareGroup || 'Unknown';
                const cpuSlotsArray = sparseToArray(host.cpuSlots, host.cpus.total);
                const gpuSlotsArray = sparseToArray(host.gpuSlots, host.gpus.total);

                cpuSlotsArray.forEach((user, idx) => {
                    const resource = new Resource(host.hostname, 'cpu', idx, user, host, hardwareGroup);
                    if (user && data.raw?.jobs?.all) {
                        const cpuJob = data.raw.jobs.all.find(job =>
                            job.user === user &&
                            job.status === 'RUN' &&
                            job.exec_host && job.exec_host.includes(host.hostname)
                        );
                        if (cpuJob) {
                            resource.jobId = cpuJob.job_id;
                            resource.jobName = cpuJob.job_name;
                        }
                    }
                    allResources.push(resource);
                    if (user && user !== '') allUsers.push(user);
                });

                gpuSlotsArray.forEach((user, idx) => {
                    const resource = new Resource(host.hostname, 'gpu', idx, user, host, hardwareGroup);
                    if (data.raw?.gpu_attribution) {
                        const gpuAttr = data.raw.gpu_attribution.find(attr =>
                            attr.hostname === host.hostname && attr.gpu_id === idx
                        );
                        if (gpuAttr) {
                            resource.jobId = gpuAttr.job_id;
                            resource.jobName = gpuAttr.job_name;
                        }
                    }
                    allResources.push(resource);
                    if (user && user !== '') allUsers.push(user);
                });
            });

            resources = allResources;
            userColorMap = generateUserColors(allUsers);

            // Re-initialize and redraw
            initializeColorStrategies();
            initializeLayoutStrategies();
            reflowLayout();
            updateCurrentModeDisplay();
            updateCurrentLayoutDisplay();
            populateLegend();
        }

        async function preloadAdjacentSnapshots(centerIndex) {
            if (!availableTimepoints?.timestamps) return;

            const timestamps = availableTimepoints.timestamps;
            const preloadPromises = [];

            for (let offset = -PRELOAD_BUFFER; offset <= PRELOAD_BUFFER; offset++) {
                if (offset === 0) continue;

                const idx = centerIndex + offset;
                if (idx < 0 || idx >= timestamps.length) continue;

                const ts = timestamps[idx];
                if (preloadedSnapshots.has(ts)) continue;

                preloadPromises.push(
                    fetch(`/api/cluster-status/${ts}`)
                        .then(r => r.json())
                        .then(data => preloadedSnapshots.set(ts, data))
                        .catch(() => {})
                );
            }

            await Promise.all(preloadPromises);
        }

        function startPlayback() {
            if (timeTravelPlaying) return;

            timeTravelPlaying = true;
            lastPlaybackTime = performance.now();

            document.getElementById('time-travel-play').innerHTML = '\u275A\u275A';
            document.getElementById('time-travel-play').classList.add('active');

            playbackLoop();
        }

        function stopPlayback() {
            timeTravelPlaying = false;

            if (playbackAnimationId) {
                cancelAnimationFrame(playbackAnimationId);
                playbackAnimationId = null;
            }

            document.getElementById('time-travel-play').innerHTML = '&#9654;';
            document.getElementById('time-travel-play').classList.remove('active');
        }

        function playbackLoop() {
            if (!timeTravelPlaying) return;
            if (!availableTimepoints?.timestamps?.length) {
                stopPlayback();
                return;
            }

            const now = performance.now();
            const elapsed = now - lastPlaybackTime;

            // Real-time interval between snapshots (based on fetch interval = 120s)
            const realInterval = 120 * 1000;
            const adjustedInterval = realInterval / timeTravelSpeed;

            if (elapsed >= adjustedInterval) {
                lastPlaybackTime = now;

                if (currentTimepointIndex < availableTimepoints.timestamps.length - 1) {
                    currentTimepointIndex++;
                    const nextTimestamp = availableTimepoints.timestamps[currentTimepointIndex];

                    document.getElementById('time-travel-slider').value = currentTimepointIndex;

                    timeTravelTimestamp = nextTimestamp;
                    loadClusterDataAt(nextTimestamp);
                    updateTimeTravelDisplay();

                    preloadAdjacentSnapshots(currentTimepointIndex);
                } else {
                    // Reached end
                    if (timeTravelLoop) {
                        // Loop back to beginning
                        currentTimepointIndex = 0;
                        const firstTimestamp = availableTimepoints.timestamps[0];
                        document.getElementById('time-travel-slider').value = 0;
                        timeTravelTimestamp = firstTimestamp;
                        loadClusterDataAt(firstTimestamp);
                        updateTimeTravelDisplay();
                        preloadAdjacentSnapshots(0);
                    } else {
                        // Switch to LIVE mode
                        returnToLive();
                        return;
                    }
                }
            }

            playbackAnimationId = requestAnimationFrame(playbackLoop);
        }

        async function returnToLive() {
            stopPlayback();

            timeTravelMode = false;
            timeTravelTimestamp = null;

            document.getElementById('time-travel-live').classList.add('active');
            updateTimeTravelDisplay();

            // Reset slider to end
            if (availableTimepoints?.timestamps) {
                const slider = document.getElementById('time-travel-slider');
                slider.value = slider.max;
                currentTimepointIndex = availableTimepoints.timestamps.length - 1;
            }

            saveStateToURL();

            // Resume with fresh data
            const loaded = await loadClusterData();
            if (loaded) {
                initializeColorStrategies();
                initializeLayoutStrategies();
                reflowLayout();
                updateCurrentModeDisplay();
                updateCurrentLayoutDisplay();
                populateLegend();
            }
        }

        function enterTimeTravelMode(timestamp, index) {
            timeTravelMode = true;
            timeTravelTimestamp = timestamp;
            currentTimepointIndex = index;

            document.getElementById('time-travel-live').classList.remove('active');
            updateTimeTravelDisplay();

            loadClusterDataAt(timestamp);
            preloadAdjacentSnapshots(index);

            saveStateToURL();
        }

        function toggleTimeTravel() {
            timeTravelExpanded = !timeTravelExpanded;
            const panel = document.getElementById('time-travel');
            if (timeTravelExpanded) {
                panel.classList.add('expanded');
            } else {
                panel.classList.remove('expanded');
            }
            saveStateToURL();
        }

        // Load cluster data from JSON
        async function loadClusterData() {
            try {
                const response = await fetch('/api/cluster-status');
                const data = await response.json();

                // Extract resources from hostDetails
                const allResources = [];
                const allUsers = [];

                data.hostDetails.forEach(host => {
                    // Use embedded hardwareGroup directly (new format)
                    const hardwareGroup = host.hardwareGroup || 'Unknown';

                    // Convert sparse slots to arrays
                    const cpuSlotsArray = sparseToArray(host.cpuSlots, host.cpus.total);
                    const gpuSlotsArray = sparseToArray(host.gpuSlots, host.gpus.total);

                    // Add CPU resources
                    cpuSlotsArray.forEach((user, idx) => {
                        const resource = new Resource(host.hostname, 'cpu', idx, user, host, hardwareGroup);

                        // Look up job info for CPU slot
                        if (user && data.raw?.jobs?.all) {
                            const cpuJob = data.raw.jobs.all.find(job =>
                                job.user === user &&
                                job.status === 'RUN' &&
                                job.exec_host && job.exec_host.includes(host.hostname)
                            );
                            if (cpuJob) {
                                resource.jobId = cpuJob.job_id;
                                resource.jobName = cpuJob.job_name;
                            }
                        }

                        allResources.push(resource);
                        if (user && user !== '') allUsers.push(user);
                    });

                    // Add GPU resources
                    gpuSlotsArray.forEach((user, idx) => {
                        const resource = new Resource(host.hostname, 'gpu', idx, user, host, hardwareGroup);

                        // Look up job info for GPU slot via gpu_attribution
                        if (data.raw?.gpu_attribution) {
                            const gpuAttr = data.raw.gpu_attribution.find(attr =>
                                attr.hostname === host.hostname && attr.gpu_id === idx
                            );
                            if (gpuAttr) {
                                resource.jobId = gpuAttr.job_id;
                                resource.jobName = gpuAttr.job_name;
                            }
                        }

                        allResources.push(resource);
                        if (user && user !== '') allUsers.push(user);
                    });
                });

                resources = allResources;
                userColorMap = generateUserColors(allUsers);

                return true;
            } catch (error) {
                console.error('Failed to load cluster data:', error);
                return false;
            }
        }

        // Apply layout strategy
        function applyLayout(strategy) {
            strategy.layout(resources, gridWidth, gridHeight);
        }

        // Initialize color strategies
        function initializeColorStrategies() {
            colorStrategies = [
                new UserColorStrategy(),
                new HostnameColorStrategy(),
                new RowColorStrategy(),
                new TypeColorStrategy(),
                new GpuTypeColorStrategy(),
                new UtilizationColorStrategy(),
                new StatusColorStrategy(),
                new HostStatusColorStrategy(),
                new MemoryLoadColorStrategy()
            ];

            // Initialize each strategy with the resources
            colorStrategies.forEach(strategy => strategy.initialize(resources));
        }

        // Initialize layout strategies
        function initializeLayoutStrategies() {
            layoutStrategies = [
                new HostnameHierarchyLayout(),
                new RackTopologyLayout(),
                new HardwareGroupLayout(),
                new UserTerritoriesLayout(),
                new JobGroupingLayout(),
                new IdleCompressionLayout(),
                new HilbertCurveLayout(),
                new SpiralLayout(),
                new RadialSunburstLayout()
            ];
        }

        // Update current layout display
        function updateCurrentLayoutDisplay() {
            const layoutDisplay = document.getElementById('current-layout');
            if (layoutDisplay && layoutStrategies.length > 0) {
                const strategy = layoutStrategies[currentLayoutMode - 1];
                layoutDisplay.textContent = 'LAYOUT: ' + strategy.getName();
            }
        }

        // Switch layout mode
        function switchLayoutMode(mode) {
            if (mode >= 1 && mode <= layoutStrategies.length) {
                currentLayoutMode = mode;
                updateCurrentLayoutDisplay();
                reflowLayout();
                saveStateToURL();
            }
        }

        // Populate legend
        function populateLegend() {
            const legendItems = document.getElementById('legend-items');
            legendItems.innerHTML = '';

            if (colorStrategies.length === 0) return;

            const colorStrategy = colorStrategies[currentColorMode - 1];
            const items = colorStrategy.getLegendItems(resources);

            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'legend-item';
                div.innerHTML = `
                    <div class="legend-color" style="background-color: ${item.color}"></div>
                    <span class="legend-user">${item.label}</span>
                    <span class="legend-count">${item.count}</span>
                `;
                legendItems.appendChild(div);
            });
        }

        // Draw the grid
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (colorStrategies.length === 0) return;

            const colorStrategy = colorStrategies[currentColorMode - 1];
            const effectivePixelSize = PIXEL_SIZE * zoomLevel;

            resources.forEach(resource => {
                const color = colorStrategy.getColor(resource);
                ctx.fillStyle = color;
                // Add +1 to width/height to prevent sub-pixel gaps between adjacent pixels
                ctx.fillRect(
                    Math.floor(resource.x * effectivePixelSize),
                    Math.floor(resource.y * effectivePixelSize),
                    Math.ceil(effectivePixelSize) + 1,
                    Math.ceil(effectivePixelSize) + 1
                );

                // Draw white border for hovered pixel
                if (currentResource && resource === currentResource) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        resource.x * effectivePixelSize + 0.5,
                        resource.y * effectivePixelSize + 0.5,
                        effectivePixelSize - 1,
                        effectivePixelSize - 1
                    );
                }
            });
        }

        // Initialize visualization
        async function init() {
            // Load state from URL if present
            const hasURLState = loadStateFromURL();

            // Set initial canvas size (if not loaded from URL)
            if (!hasURLState) {
                // Fit canvas to window: 95% width, below buttons with margin
                const topMargin = 85;  // Space for help/legend buttons
                const bottomMargin = 85;  // Space for zoom controls at bottom
                const sideMargin = window.innerWidth * 0.025;  // 2.5% on each side = 95% width

                canvasWidth = Math.floor(window.innerWidth * 0.95);
                canvasHeight = Math.floor(window.innerHeight - topMargin - bottomMargin);
                canvasX = sideMargin;
                canvasY = topMargin;
                updateCanvasPosition();
            } else {
                // Apply loaded position and size
                updateCanvasPosition();
            }

            updateCanvasSize();

            // Initialize zoom display
            updateZoomDisplay();

            const loaded = await loadClusterData();

            if (loaded) {
                // Initialize strategies
                initializeColorStrategies();
                initializeLayoutStrategies();

                // Apply layout with proper reflow (accounts for zoom level)
                reflowLayout();
                updateCurrentModeDisplay();
                updateCurrentLayoutDisplay();
                populateLegend();

                // Apply panel states from URL
                if (hasURLState) {
                    if (legendExpanded) {
                        legend.classList.add('expanded');
                    }
                    if (helpExpanded) {
                        help.classList.add('expanded');
                    }
                }

                // Initialize time travel panel
                await initTimeTravel();

                // Apply time travel state from URL if present
                if (timeTravelTimestamp && availableTimepoints?.timestamps) {
                    const index = availableTimepoints.timestamps.indexOf(timeTravelTimestamp);
                    if (index !== -1) {
                        currentTimepointIndex = index;
                        document.getElementById('time-travel-slider').value = index;
                        enterTimeTravelMode(timeTravelTimestamp, index);
                    }
                }

                // Apply time travel panel expansion state
                if (timeTravelExpanded) {
                    document.getElementById('time-travel').classList.add('expanded');
                }

                // Save initial state to URL
                saveStateToURL();
            } else {
                // Fallback: show error message
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px monospace';
                ctx.fillText('Failed to load cluster-status.json', 20, 30);
            }

            // Set up time travel event handlers (always, even if data load fails)
            setupTimeTravelEventHandlers();
        }

        // Refresh data periodically without changing user settings
        async function refreshData() {
            // Skip refresh if in time travel mode
            if (timeTravelMode) {
                console.log(`[${new Date().toISOString()}] Skipping refresh (time travel mode active)`);
                return;
            }

            console.log(`[${new Date().toISOString()}] Refreshing cluster data...`);

            const loaded = await loadClusterData();

            if (loaded) {
                // Re-initialize strategies with new data
                initializeColorStrategies();
                initializeLayoutStrategies();

                // Re-apply layout (preserves zoom, canvas position/size)
                const layoutStrategy = layoutStrategies[currentLayoutMode - 1];
                applyLayout(layoutStrategy);

                // Redraw with current settings preserved
                draw();

                // Update displays with new data
                updateCurrentModeDisplay();
                updateCurrentLayoutDisplay();
                populateLegend();

                console.log(`[${new Date().toISOString()}] Cluster data refreshed successfully`);
            } else {
                console.error(`[${new Date().toISOString()}] Failed to refresh cluster data`);
            }
        }

        // Set up periodic data refresh (every 2 minutes)
        const REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes in milliseconds
        setInterval(refreshData, REFRESH_INTERVAL);

        // Handle window resize
        window.addEventListener('resize', () => {
            // Canvas size stays the same, only ensure it's still visible
            const maxX = window.innerWidth - canvasWidth;
            const maxY = window.innerHeight - canvasHeight;

            // Keep canvas within viewport bounds
            canvasX = Math.max(0, Math.min(canvasX, maxX));
            canvasY = Math.max(0, Math.min(canvasY, maxY));

            updateCanvasPosition();
            // Note: Don't re-layout or resize canvas - maintain user's chosen size
        });

        // Tooltip handling
        const tooltip = document.getElementById('tooltip');
        let currentResource = null;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate grid position using effective pixel size
            const effectivePixelSize = PIXEL_SIZE * zoomLevel;
            const gridX = Math.floor(mouseX / effectivePixelSize);
            const gridY = Math.floor(mouseY / effectivePixelSize);

            // Find resource at this position
            const resource = resources.find(r => r.x === gridX && r.y === gridY);

            if (resource) {
                currentResource = resource;
                showTooltip(resource);
            } else {
                hideTooltip();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hideTooltip();
        });

        // Canvas drag functionality
        const container = document.getElementById('canvas-container');

        canvas.addEventListener('mousedown', (e) => {
            // Save click position for distinguishing click from drag
            clickStartX = e.clientX;
            clickStartY = e.clientY;

            // Allow dragging from anywhere on the canvas
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCanvasX = canvasX;
            dragStartCanvasY = canvasY;
            container.classList.add('dragging');
            e.preventDefault();
        });

        document.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                container.classList.remove('dragging');
                saveStateToURL();
            }
            if (isResizing) {
                isResizing = false;
                resizeHandle = null;
                saveStateToURL();
            }
        });

        // Corner resize handlers
        const resizeHandles = document.querySelectorAll('.resize-handle');

        resizeHandles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                resizeHandle = e.target.dataset.corner;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartCanvasX = canvasX;
                dragStartCanvasY = canvasY;
                dragStartCanvasWidth = canvasWidth;
                dragStartCanvasHeight = canvasHeight;
                e.stopPropagation();
                e.preventDefault();
            });
        });

        // Handle resize dragging (combined with drag mousemove)
        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                switch(resizeHandle) {
                    case 'top-left':
                        // Move top-left corner
                        canvasX = dragStartCanvasX + dx;
                        canvasY = dragStartCanvasY + dy;
                        canvasWidth = Math.max(MIN_CANVAS_SIZE, dragStartCanvasWidth - dx);
                        canvasHeight = Math.max(MIN_CANVAS_SIZE, dragStartCanvasHeight - dy);
                        break;
                    case 'top-right':
                        // Move top-right corner
                        canvasY = dragStartCanvasY + dy;
                        canvasWidth = Math.max(MIN_CANVAS_SIZE, dragStartCanvasWidth + dx);
                        canvasHeight = Math.max(MIN_CANVAS_SIZE, dragStartCanvasHeight - dy);
                        break;
                    case 'bottom-left':
                        // Move bottom-left corner
                        canvasX = dragStartCanvasX + dx;
                        canvasWidth = Math.max(MIN_CANVAS_SIZE, dragStartCanvasWidth - dx);
                        canvasHeight = Math.max(MIN_CANVAS_SIZE, dragStartCanvasHeight + dy);
                        break;
                    case 'bottom-right':
                        // Move bottom-right corner
                        canvasWidth = Math.max(MIN_CANVAS_SIZE, dragStartCanvasWidth + dx);
                        canvasHeight = Math.max(MIN_CANVAS_SIZE, dragStartCanvasHeight + dy);
                        break;
                }

                updateCanvasPosition();
                updateCanvasSize();

                // Re-layout resources to fit new canvas size
                reflowLayout();
            } else if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                canvasX = dragStartCanvasX + dx;
                canvasY = dragStartCanvasY + dy;

                updateCanvasPosition();
            }
        });

        // Pinch-to-zoom gesture support
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                e.preventDefault();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const delta = distance - lastTouchDistance;
                const zoomChange = delta * 0.01;  // Sensitivity factor

                zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel + zoomChange));
                lastTouchDistance = distance;

                updateZoomDisplay();
                reflowLayout();
                e.preventDefault();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            // Save state after touch gesture ends (e.g., after pinch-to-zoom)
            if (lastTouchDistance > 0) {
                saveStateToURL();
                lastTouchDistance = 0;
            }
        });

        function showTooltip(resource) {
            const userText = resource.isIdle
                ? '<span class="idle">IDLE</span>'
                : `<span class="value">${resource.user}</span>`;

            tooltip.innerHTML = `
                <span class="label">HOST:</span> <span class="value">${resource.hostname}</span> |
                <span class="label">TYPE:</span> <span class="value">${resource.type.toUpperCase()}</span> |
                <span class="label">SLOT:</span> <span class="value">#${resource.index}</span> |
                <span class="label">USER:</span> ${userText}
            `;

            // Always show tooltip at the bottom
            tooltip.classList.add('visible');
            draw(); // Redraw to show hover border
        }

        function hideTooltip() {
            currentResource = null;
            tooltip.classList.remove('visible');
            draw(); // Redraw to remove hover border
        }

        // Update current mode display
        function updateCurrentModeDisplay() {
            const currentModeDisplay = document.getElementById('current-mode');
            if (currentModeDisplay) {
                currentModeDisplay.textContent = `Color ${MODE_DESCRIPTIONS[currentColorMode - 1]}`;
            }
        }

        // Mode switching
        function switchColorMode(mode) {
            if (mode >= 1 && mode <= 9 && colorStrategies.length > 0) {
                currentColorMode = mode;
                updateCurrentModeDisplay();
                populateLegend();
                draw();
                saveStateToURL();
            }
        }

        // Help panel toggle
        const help = document.getElementById('help');
        const helpTitle = document.getElementById('help-title');
        let helpExpanded = false;

        function toggleHelp() {
            helpExpanded = !helpExpanded;
            if (helpExpanded) {
                help.classList.add('expanded');
            } else {
                help.classList.remove('expanded');
            }
            saveStateToURL();
        }

        helpTitle.addEventListener('click', toggleHelp);

        // Legend toggle
        const legend = document.getElementById('legend');
        const legendTitle = document.getElementById('legend-title');
        let legendExpanded = false;

        function toggleLegend() {
            legendExpanded = !legendExpanded;
            if (legendExpanded) {
                legend.classList.add('expanded');
            } else {
                legend.classList.remove('expanded');
            }
            saveStateToURL();
        }

        legendTitle.addEventListener('click', toggleLegend);

        // Zoom functions
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                updateZoomDisplay();
                reflowLayout();
                saveStateToURL();
            }
        }

        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                updateZoomDisplay();
                reflowLayout();
                saveStateToURL();
            }
        }

        function reflowLayout() {
            // Recalculate grid dimensions based on effective pixel size
            const effectivePixelSize = PIXEL_SIZE * zoomLevel;
            gridWidth = Math.floor(canvasWidth / effectivePixelSize);
            gridHeight = Math.floor(canvasHeight / effectivePixelSize);

            // Re-layout resources to fit new grid
            if (resources.length > 0 && layoutStrategies.length > 0) {
                const layoutStrategy = layoutStrategies[currentLayoutMode - 1];
                applyLayout(layoutStrategy);
                draw();
            }
        }

        // Set up time travel event handlers
        function setupTimeTravelEventHandlers() {
            console.log('Setting up time travel event handlers');

            // Panel toggle
            document.getElementById('time-travel-title').addEventListener('click', toggleTimeTravel);

            // Slider change
            document.getElementById('time-travel-slider').addEventListener('input', (e) => {
                if (!availableTimepoints?.timestamps?.length) return;
                const index = parseInt(e.target.value);
                if (index >= 0 && index < availableTimepoints.timestamps.length) {
                    const timestamp = availableTimepoints.timestamps[index];
                    enterTimeTravelMode(timestamp, index);
                }
            });

            // Play/Pause
            document.getElementById('time-travel-play').addEventListener('click', () => {
                if (!availableTimepoints?.timestamps?.length) {
                    console.log('No timepoints available for playback');
                    return;
                }
                if (timeTravelPlaying) {
                    stopPlayback();
                } else {
                    if (!timeTravelMode) {
                        // Start from beginning if currently LIVE
                        enterTimeTravelMode(availableTimepoints.timestamps[0], 0);
                    }
                    startPlayback();
                }
            });

            // Loop toggle
            document.getElementById('time-travel-loop').addEventListener('click', () => {
                timeTravelLoop = !timeTravelLoop;
                document.getElementById('time-travel-loop').classList.toggle('active', timeTravelLoop);
            });

            // Prev button
            document.getElementById('time-travel-prev').addEventListener('click', () => {
                if (!availableTimepoints?.timestamps?.length) return;
                if (currentTimepointIndex > 0) {
                    currentTimepointIndex--;
                    const timestamp = availableTimepoints.timestamps[currentTimepointIndex];
                    document.getElementById('time-travel-slider').value = currentTimepointIndex;
                    enterTimeTravelMode(timestamp, currentTimepointIndex);
                }
            });

            // Next button
            document.getElementById('time-travel-next').addEventListener('click', () => {
                if (!availableTimepoints?.timestamps?.length) return;
                if (currentTimepointIndex < availableTimepoints.timestamps.length - 1) {
                    currentTimepointIndex++;
                    const timestamp = availableTimepoints.timestamps[currentTimepointIndex];
                    document.getElementById('time-travel-slider').value = currentTimepointIndex;
                    enterTimeTravelMode(timestamp, currentTimepointIndex);
                }
            });

            // Speed selector
            document.getElementById('time-travel-speed').addEventListener('change', (e) => {
                timeTravelSpeed = parseFloat(e.target.value);
                saveStateToURL();
            });

            // LIVE button
            document.getElementById('time-travel-live').addEventListener('click', returnToLive);

            console.log('Time travel event handlers attached');
        }

        // Zoom button event listeners
        document.getElementById('zoom-in').addEventListener('click', zoomIn);
        document.getElementById('zoom-out').addEventListener('click', zoomOut);

        // Click zoom level to reset to 100%
        document.getElementById('zoom-level').addEventListener('click', () => {
            zoomLevel = 1.0;
            updateZoomDisplay();
            reflowLayout();
            saveStateToURL();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // +/- keys for zoom
            if (e.key === '+' || e.key === '=') {
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                zoomOut();
            }

            // L to toggle legend
            if (e.key === 'l' || e.key === 'L') {
                toggleLegend();
            }

            // ? to toggle help
            if (e.key === '?') {
                toggleHelp();
            }

            // T to toggle time travel
            if (e.key === 't' || e.key === 'T') {
                toggleTimeTravel();
            }

            // Number keys: Shift+N for layouts, N for color modes
            // Use e.code to handle Shift+number (since e.key becomes @, #, etc.)
            const digitMatch = e.code?.match(/^Digit(\d)$/);
            if (digitMatch) {
                const key = parseInt(digitMatch[1]);
                if (e.shiftKey) {
                    // Shift+1-9 for layout modes
                    switchLayoutMode(key);
                } else {
                    // 1-9 for color modes
                    switchColorMode(key);
                }
            }

            // ESC to close modal
            if (e.key === 'Escape') {
                closeModal();
            }

            // Arrow keys to navigate when modal is open
            if (modalOverlay.classList.contains('visible')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    navigateToPrevious();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateToNext();
                }
            }
        });

        // Modal handling
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalStatus = document.getElementById('modal-status');
        const modal = document.getElementById('modal');
        const modalNavLeft = document.getElementById('modal-nav-left');
        const modalNavRight = document.getElementById('modal-nav-right');

        let currentResourceIndex = -1;

        function createBarGraph(label, value, max) {
            const percentage = max > 0 ? Math.min(100, (value / max) * 100) : 0;
            const isOverflow = value > max;
            const displayValue = value.toFixed(1);
            const barColor = isOverflow ? 'background: linear-gradient(90deg, #ff0000, #ff4444);' : 'background: linear-gradient(90deg, #00ff00, #44ff44);';

            return `
                <div class="bar-graph-row">
                    <div class="bar-graph-label">${label}</div>
                    <div class="bar-graph-container">
                        <div class="bar-graph-fill" style="width: ${percentage}%; ${barColor}"></div>
                    </div>
                    <div class="bar-graph-value">${displayValue}</div>
                </div>
            `;
        }

        function showModal(resource) {
            const statusBadge = resource.isIdle
                ? '<span class="status-badge idle">IDLE</span>'
                : '<span class="status-badge in-use">IN-USE</span>';

            // Update header with hostname and slot#, status badge in upper right
            modalTitle.textContent = `${resource.hostname} - ${resource.type.toUpperCase()} #${resource.index}`;
            modalStatus.innerHTML = statusBadge;

            // Column 1: Basic info
            let column1 = `
                <div>
                    <div class="modal-section">
                        <div class="modal-section-title">BASIC INFO</div>
                        <div class="modal-info-row">
                            <div class="modal-label">TYPE:</div>
                            <div class="modal-value">${resource.type.toUpperCase()}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">HARDWARE:</div>
                            <div class="modal-value">${resource.hardwareGroup}</div>
                        </div>
                        <div class="modal-info-row">
                            <div class="modal-label">HOST STATUS:</div>
                            <div class="modal-value">${resource.status}</div>
                        </div>
                        ${resource.gpuType ? `
                        <div class="modal-info-row">
                            <div class="modal-label">GPU TYPE:</div>
                            <div class="modal-value">${resource.gpuType}</div>
                        </div>
                        ` : ''}
                    </div>

                    ${(resource.user || resource.jobId) ? `
                    <div class="modal-section">
                        <div class="modal-section-title">JOB INFO</div>
                        ${resource.user ? `
                        <div class="modal-info-row">
                            <div class="modal-label">USER:</div>
                            <div class="modal-value">${resource.user}</div>
                        </div>
                        ` : ''}
                        ${resource.jobId ? `
                        <div class="modal-info-row">
                            <div class="modal-label">JOB ID:</div>
                            <div class="modal-value">${resource.jobId}</div>
                        </div>
                        ` : ''}
                        ${resource.jobName ? `
                        <div class="modal-info-row">
                            <div class="modal-label">JOB NAME:</div>
                            <div class="modal-value">${resource.jobName}</div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
            `;

            // Column 2: All load metrics combined
            let column2 = '<div>';
            if (resource.load && Object.keys(resource.load).length > 0) {
                const load = resource.load;
                const memoryGB = load.mem !== undefined ? formatMemoryGB(load.mem, 2) : null;
                const diskIO = load.io !== undefined ? load.io.toFixed(1) : null;

                column2 += `
                    <div class="modal-section">
                        <div class="modal-section-title">USAGE</div>
                        <div class="modal-info-row">
                            <div class="modal-label">UTILIZATION:</div>
                            <div class="modal-value">${resource.utilization}%</div>
                        </div>
                        ${memoryGB ? `
                        <div class="modal-info-row">
                            <div class="modal-label">MEMORY AVAIL:</div>
                            <div class="modal-value">${memoryGB} GB</div>
                        </div>
                        ` : ''}
                        ${diskIO ? `
                        <div class="modal-info-row">
                            <div class="modal-label">DISK I/O:</div>
                            <div class="modal-value">${diskIO} KB/s</div>
                        </div>
                        ` : ''}
                        <div class="bar-graph">
                            ${load.r15s !== undefined ? createBarGraph('15s', load.r15s, 100) : ''}
                            ${load.r1m !== undefined ? createBarGraph('1min', load.r1m, 100) : ''}
                            ${load.r15m !== undefined ? createBarGraph('15min', load.r15m, 100) : ''}
                            ${load.ut !== undefined ? createBarGraph('CPU %', load.ut, 100) : ''}
                            ${load.tmp !== undefined ? createBarGraph('Temp', load.tmp / 1000, 10000) : ''}
                        </div>
                    </div>
                `;
            }
            column2 += '</div>';

            modalContent.innerHTML = column1 + column2;
            modalOverlay.classList.add('visible');
            updateNavigationArrows();
        }

        function updateNavigationArrows() {
            if (currentResourceIndex <= 0) {
                modalNavLeft.classList.remove('visible');
            } else {
                modalNavLeft.classList.add('visible');
            }

            if (currentResourceIndex >= resources.length - 1) {
                modalNavRight.classList.remove('visible');
            } else {
                modalNavRight.classList.add('visible');
            }
        }

        function navigateToPrevious() {
            if (currentResourceIndex > 0) {
                currentResourceIndex--;
                showModal(resources[currentResourceIndex]);
            }
        }

        function navigateToNext() {
            if (currentResourceIndex < resources.length - 1) {
                currentResourceIndex++;
                showModal(resources[currentResourceIndex]);
            }
        }

        function closeModal() {
            modalOverlay.classList.remove('visible');
            modalNavLeft.classList.remove('visible');
            modalNavRight.classList.remove('visible');
            currentResourceIndex = -1;
        }

        // Click anywhere on modal or overlay to close
        modalOverlay.addEventListener('click', closeModal);
        modal.addEventListener('click', closeModal);

        // Navigation arrow click handlers
        modalNavLeft.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateToPrevious();
        });

        modalNavRight.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateToNext();
        });

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            // Only open modal if mouse hasn't moved much (not a drag)
            const dx = e.clientX - clickStartX;
            const dy = e.clientY - clickStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 5) {  // Threshold for click vs drag
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate grid position using effective pixel size
                const effectivePixelSize = PIXEL_SIZE * zoomLevel;
                const gridX = Math.floor(mouseX / effectivePixelSize);
                const gridY = Math.floor(mouseY / effectivePixelSize);

                const resource = resources.find(r => r.x === gridX && r.y === gridY);

                if (resource) {
                    currentResourceIndex = resources.indexOf(resource);
                    showModal(resource);
                }
            }
        });

        // Start
        init();
    </script>
</body>
</html>
